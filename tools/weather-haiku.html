<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Weather Haiku | Jade Michael Thornton</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="A haiku for your weather" />
    <meta name="robots" content="index, follow" />
    <meta name="googlebot" content="index, follow" />
    <link rel="shortcut icon" href="/assets/images/favicon.png" />
    <link
      rel="preload"
      href="/assets/fonts/MetroNova-Regular.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="/assets/fonts/MetroNova-Italic.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="/assets/style/main.css" type="text/css" />
    <style>
      body {
        background: #f8f9fa;
        color: #2d3748;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-family:
          "MetroNova",
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          sans-serif;
        line-height: 1.6;
      }

      .container {
        max-width: 600px;
        padding: 2rem;
        text-align: center;
      }

      .haiku {
        font-size: 1.5rem;
        line-height: 1.8;
        margin: 2rem 0;
        white-space: pre-line;
        font-style: italic;
        color: #4a5568;
      }

      .location {
        font-size: 0.9rem;
        color: #718096;
        margin-bottom: 1rem;
      }

      .loading {
        opacity: 0.6;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.6;
        }
        50% {
          opacity: 1;
        }
      }

      .error {
        color: #e53e3e;
        font-size: 1rem;
      }

      header,
      nav {
        display: none;
      }

      .refresh-hint {
        font-size: 0.8rem;
        color: #a0aec0;
        margin-top: 2rem;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="location" id="location">Finding your location...</div>
      <div class="haiku loading" id="haiku">
        Waiting for the sky To reveal its gentle mood Patience brings wisdom
      </div>
      <div class="refresh-hint">Refresh for a new haiku</div>
    </div>

    <script>
      "use strict";

      const weatherConditions = {
        clear: ["bright", "sunny", "golden", "radiant", "gleaming"],
        cloudy: ["gray", "overcast", "shadowed", "veiled", "dim"],
        rain: ["wet", "dripping", "showering", "pouring", "moist"],
        snow: ["white", "frozen", "crystalline", "pure", "silent"],
        storm: ["turbulent", "wild", "fierce", "rumbling", "electric"],
        fog: ["misty", "shrouded", "ethereal", "ghostly", "soft"],
        wind: ["breezy", "gusty", "swirling", "dancing", "flowing"],
      };

      const haikuTemplates = [
        {
          pattern:
            "{weather} {sky_noun} above\n{nature_verb} through the {time_adj} air\n{emotion} fills my heart",
          vars: {
            sky_noun: ["clouds", "heavens", "expanse", "dome", "canvas"],
            nature_verb: [
              "Dancing",
              "Drifting",
              "Flowing",
              "Whispers",
              "Floating",
            ],
            time_adj: ["morning", "evening", "quiet", "gentle", "cool"],
            emotion: ["Peace", "Wonder", "Calm", "Joy", "Grace"],
          },
        },
        {
          pattern:
            "{temp_desc} {season_noun} day\n{weather_verb} {nature_noun} softly\n{time_phrase}",
          vars: {
            temp_desc: ["Cool", "Warm", "Crisp", "Mild", "Fresh"],
            season_noun: ["winter", "spring", "summer", "autumn", "season"],
            weather_verb: [
              "Embraces",
              "Touches",
              "Kisses",
              "Caresses",
              "Holds",
            ],
            nature_noun: ["earth", "leaves", "grass", "flowers", "trees"],
            time_phrase: [
              "Moment breathes deep",
              "Time stands still",
              "Now is enough",
              "Present unfolds",
              "Stillness speaks",
            ],
          },
        },
        {
          pattern:
            "{weather_noun} {weather_verb}\n{nature_adj} {nature_noun} {action_verb}\n{wisdom_phrase}",
          vars: {
            weather_noun: ["Rain", "Wind", "Sun", "Mist", "Breeze"],
            weather_verb: ["whispers", "sings", "dances", "speaks", "calls"],
            nature_adj: ["Ancient", "Gentle", "Wise", "Silent", "Patient"],
            nature_noun: ["trees", "stones", "rivers", "mountains", "fields"],
            action_verb: ["listen", "respond", "remember", "endure", "witness"],
            wisdom_phrase: [
              "Truth needs no words",
              "Beauty simply is",
              "Peace flows within",
              "Life continues on",
              "Love remains constant",
            ],
          },
        },
      ];

      function generateHaiku(weatherData) {
        const template =
          haikuTemplates[Math.floor(Math.random() * haikuTemplates.length)];
        let haiku = template.pattern;

        // Replace weather-specific terms
        const condition = detectWeatherCondition(weatherData);
        const weatherAdjs =
          weatherConditions[condition] || weatherConditions["clear"];
        haiku = haiku.replace(
          "{weather}",
          capitalize(
            weatherAdjs[Math.floor(Math.random() * weatherAdjs.length)],
          ),
        );

        // Replace template variables
        Object.entries(template.vars).forEach(([key, values]) => {
          const value = values[Math.floor(Math.random() * values.length)];
          haiku = haiku.replace(new RegExp(`{${key}}`, "g"), value);
        });

        return haiku;
      }

      function detectWeatherCondition(data) {
        const desc = data.detailedForecast.toLowerCase();
        if (desc.includes("rain") || desc.includes("shower")) return "rain";
        if (desc.includes("snow") || desc.includes("flurr")) return "snow";
        if (desc.includes("storm") || desc.includes("thunder")) return "storm";
        if (desc.includes("fog") || desc.includes("mist")) return "fog";
        if (desc.includes("wind") || desc.includes("breezy")) return "wind";
        if (desc.includes("cloud") || desc.includes("overcast"))
          return "cloudy";
        if (desc.includes("clear") || desc.includes("sunny")) return "clear";
        return "clear";
      }

      function capitalize(word) {
        return word.charAt(0).toUpperCase() + word.slice(1);
      }

      async function getWeather(lat, lon) {
        try {
          // Get grid point from coordinates
          const pointResponse = await fetch(
            `https://api.weather.gov/points/${lat},${lon}`,
          );
          const pointData = await pointResponse.json();

          // Get forecast from grid point
          const forecastResponse = await fetch(pointData.properties.forecast);
          const forecastData = await forecastResponse.json();

          return forecastData.properties.periods[0];
        } catch (error) {
          throw new Error("Unable to fetch weather data");
        }
      }

      async function getLocationName(lat, lon) {
        try {
          const response = await fetch(
            `https://api.weather.gov/points/${lat},${lon}`,
          );
          const data = await response.json();
          return `${data.properties.relativeLocation.properties.city}, ${data.properties.relativeLocation.properties.state}`;
        } catch (error) {
          return `${lat.toFixed(2)}, ${lon.toFixed(2)}`;
        }
      }

      function showError(message) {
        document.getElementById("location").textContent = "";
        document.getElementById("haiku").className = "haiku error";
        document.getElementById("haiku").textContent = message;
      }

      async function init() {
        if (!navigator.geolocation) {
          showError(
            "Geolocation not supported\nRefresh to try again\nOr enable location",
          );
          return;
        }

        navigator.geolocation.getCurrentPosition(
          async (position) => {
            try {
              const { latitude, longitude } = position.coords;

              const [weatherData, locationName] = await Promise.all([
                getWeather(latitude, longitude),
                getLocationName(latitude, longitude),
              ]);

              document.getElementById("location").textContent = locationName;
              document.getElementById("haiku").className = "haiku";
              document.getElementById("haiku").textContent =
                generateHaiku(weatherData);
            } catch (error) {
              showError(
                "Weather unavailable\nTry refreshing the page\nSky keeps its secrets",
              );
            }
          },
          (error) => {
            let message =
              "Location unknown\nGrant permission and refresh\nTo hear sky's story";
            if (error.code === error.TIMEOUT) {
              message =
                "Location search slow\nRefresh to try once again\nPatience brings wisdom";
            }
            showError(message);
          },
          { timeout: 10000, maximumAge: 300000 },
        );
      }

      init();
    </script>
  </body>
</html>
