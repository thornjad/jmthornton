<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>What's new in ECMAScript 2017 | Blog | Jade Thornton</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link type="text/plain" rel="author" href="https://jmthornton.net/humans.txt" />

    <meta name="robots" content="index, follow" />
    <meta name="googlebot" content="index, follow" />
    <meta name="google-site-verification" content="JUM1Dl9n9ic9xPMb03Nzf4NgW_-8PWZrJ4eJGC_PoYM" />
    <link rel="shortcut icon" href="https://jmthornton.net/assets/images/favicon.png" />
    <link rel="apple-itouch-icon" href="https://jmthornton.net/assets/images/favicon.ico" />

    <link rel="stylesheet" href="https://jmthornton.net/assets/style/main.css" type="text/css" />

    <!-- twitter tags reference: https://dev.twitter.com/cards/markup -->
    <!-- opengraph tags reference: http://ogp.me -->

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@jmthorntonwhat">
    <meta name="twitter:creator" content="@jmthorntonwhat">

    <!-- max 70 chars -->
    <meta property="og:title" content="What's new in ECMAScript 2017">
    <meta name="twitter:title" content="What's new in ECMAScript 2017">

    <!-- max 200 chars -->
    <meta name="description" content="Two years ago, ES6 gave a massive update to the already powerful ECMAScript standard. This year's release, ECMAScript 2017, provides several new features and changes. Let's take a look">
    <meta name="og:description" content="Two years ago, ES6 gave a massive update to the already powerful ECMAScript standard. This year's release, ECMAScript 2017, provides several new features and changes. Let's take a look">
    <meta name="twitter:description" content="Two years ago, ES6 gave a massive update to the already powerful ECMAScript standard. This year's release, ECMAScript 2017, provides several new features and changes. Let's take a look">

    <meta property="og:image" content="https://blog.jmthornton.net/assets/images/icon.png">
    <meta name="twitter:image" content="https://blog.jmthornton.net/assets/images/icon.png">

    <meta property="og:url" content="https://blog.jmthornton.net/p/post">
    <meta property="og:site_name" content="blog.jmthornton.net">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="en_US" />

    <meta name="article:author" content="https://jmthornton.net">
    <meta property="article:published_time" content="2017-09-29">
  </head>
  <body>
    <header><nav>
      <a href="https://jmthornton.net">Home</a>
      <a href="/tools">Tools</a>
      <a href="https://blog.jmthornton.net">Blog</a>
      <a href="https://photos.jmthornton.net">Photos</a>
    </nav></header>

    <main>
      <article class="post blog-content">
        <h1 class="post-title">What's new in ECMAScript 2017</h1>
				<time datetime="2017-09-29">September 29, 2017</time>

        <div class="post-main">
          <div class="blog-body">
            <p>
              Two years ago, ES6 (retconned to ECMAScript 2015) provided a massive update to the existing and already powerful ECMAScript standard. Incredibly useful features like <code>const</code>, <code>let</code>, arrow functions and destructuring syntax were unleashed upon the world. Another big change was the new yearly release schedule based on <a href="https://github.com/tc39/proposals">proposals</a> are ready to ship as of the <a href="https://github.com/tc39">TC39</a> meeting. The next annual release, ECMAScript 2016, wasn't much to gawk at in comparison, adding only two new features&mdash;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">Array.protoype.includes</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Exponentiation_(**)">exponentiation operator</a>&mdash;and a handful of changes to the existing standard.
            </p>
            <p>
              The newly released <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">ECMAScript 2017</a> is somewhere in between, not being a massive update, but adding a sizeable number of features and changes. Let's take a look at all the new additions in this year's release.
            </p>

            <h4>Object.values and Object.entries</h4>
            <p>The first addition to ECMAScript 2017 liberates us from jQuery dependence when it comes to enumerating pairs of entries or values from objects. This adds two new methods to the Object prototype, complementing pre-existing methods like <code>keys()</code>. <code>values()</code> returns an array of all values, without the keys, while <code>entries()</code> returns a two dimensional array of keys and values. Let's see an example use:</p>
            <pre>const jmthornton = {
  name: 'Jade',
  writes: 'code'
};

Object.entries(jmthornton);
// [['name', 'Jade'], ['writes', 'code']]</pre>
            <pre>const jmthornton = {
  name: 'Jade',
  writes: 'code'
};

Objects.values(jmthornton);
// ['Jade', 'code']</pre>
            <p>
              Documentation:
              <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">MDN: Object.entries()</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values">MDN: Object.values()</a></li>
              </ul>
            </p>

            <h4>String padding</h4>
            <p>This new feature is relatively small, but comes to the rescue of npm and Node itself. If you don't remember, March 2016 saw <a href="http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">a bit of a crisis</a> where a widely used package (even by Node and Babel) called <code>left-pad</code> was unpublished from npm and crippled developers everywhere. This new ECMAScript feature makes the package unneeded. You can use it to easily format string output so the string reaches the given length:</p>
            <pre>'foobaring foo'.padStart(20);       // "       foobaring foo"
'foobaring foo'.padStart(20, '#');  // "#######foobaring foo"

'foobaring foo'.padEnd(20);         // "foobaring foo       "
'foobaring foo'.padEnd(20, '#');    // "foobaring foo#######"</pre>
            <p>
              Documentation:
              <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart">MDN: String.prototype.padStart()</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd">MDN: String.prototype.padEnd()</a></li>
              </ul>
            </p>

            <h4>Object.getOwnPropertyDescriptors</h4>
            <p>Copying objects manually is never fun, and comes with a lot of uncertainty, and with the rising awareness and use of functional programming, immutability is very important. The new method on the <code>Object</code> prototype solves this issue once and for all. <code>Object.getOwnPropertyDescriptors</code> takes in an <code>Object</code> and returns the descriptors describing the attributes of a property (like value, if it's writable, etc.) Here's an example of how it's used:</p>
            <pre>const source = {
  name: 'Jackie Smith',
  id: 555
};

const sourceClone = Object.create(
  Object.getPrototypeOf(source),
  Object.getOwnPropertyDescriptors(source)
);

const stateClone = Object.create(
  Object.getPrototypeOf(this.state),
  Object.getOwnPropertyDescriptors(this.state)
);

// make changes to stateClone

this.setState(stateClone);</pre>
            <p>Documentation:
              <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">MDN: Object.getOwnPropertyDescriptor()</a></li>
              </ul></p>

            <h4 class="hash-line-2"><a class="hash-anchor" id="trailing-commas" href="#trailing-commas">##</a>Trailing commas in function parameter lists and calls</h4>
            <p>This new update is purely aesthetic, allowing trailing commas in function parameter lists and calls. For a long time, we've been able to put trailing commas in objects and arrays, so it's only fitting that parameter lists join the ranks. There's no performance or big underlying changes here, but I think it's a good addition. Example for clarity:</p>
            <pre>function foo(
    paramA,
    paramB,
    paramC,
  ) {
  console.log('No more complaints from the compiler!');
}</pre>
            <p>Documentation:
              <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas">MDN: Trailing commas</a></li>
              </ul></p>

            <h4>Async functions</h4>
            <p>A solution to chained callbacks, that all-too-common pattern especially prevalent with APIs, async functions are a bit of syntatic sugar, but they let you write promise-based code in a way that looks synchronous. As <a href="https://developers.google.com/web/fundamentals/primers/async-functions">Jake Archibald</a> puts it, it makes "your asynchronous code less 'clever' and more readable". Check out <a href="https://ponyfoo.com/articles/understanding-javascript-async-await">this excellent in-depth walk-through</a> by Nicol√°s Bevacqua. Here's the gist of the syntax:</p>
            <pre>async function doTheThing(data) {
  try {
    const valA = await anAsyncFunction(data);
    const valB = await aDifferentAsyncFunction(valA);
    console.log(`valB: ${valB}`);
  } catch (err) {
    console.error(`Oh noes! ${err}`);
  }
}</pre>
            <p>And to use it with an arrow function:</p>
            <pre>const doTheThing = async (data) => {
  try {
    const valA = await anAsyncFunction(data);
    const valB = await aDifferentAsyncFunction(valA);
    console.log(`valB: ${valB}`);
  } catch (err) {
    console.error(`Oh noes! ${err}`);
  }
}</pre>
            <p>Documentation:
              <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN: async function</a></li>
              </ul></p>

            <h4>Shared memory and atomics</h4>
            <p>This new addition is a little more technical than others, but definitely one of the coolest. It adds a new <code>SharedArrayBuffer</code>, and allows the already-existing <code>TypedArray</code> and <code>DataView</code> types to be used to allocate shared memory. The associated <code>Atomics</code> object allows operations to be carried out on that shared memory. <a href="https://tc39.github.io/ecmascript_sharedmem/shmem.html">The proposal</a> states these cases for justification:</p>
            <blockquote cite="ECMA TC39 - Lars T Hansen">
              <ul>
                <li>Support for threaded code in programs written in other languages that are translated to asm.js or plain JS or a combination of the two, notably C and C++ but also other, safe, languages.</li>
                <li>Support for hand-written JS or JS+asm.js that makes use of multiprocessing facilities for select tasks, such as image processing, asset management, or game AI.</li>
              </ul>
            </blockquote>
            <p>The author of the proposal, Lars T Hansen, provides a <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/TUTORIAL.md">tutorial</a> for use of shared memory, and Dr Axel Rauschmayer <a href="http://2ality.com/2017/01/shared-array-buffer.html">dives in</a> to explain it all in depth in a long form article.</p>
            <p>Documentation:
              <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics">MDN: Atomics</a></li>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">MDN: SharedArrayBuffer</a></li>
              </ul></p>

            <hr class="blog-conclusion-separator">

            <p>That's it for ECMAScript 2017! Lots of new changes, and all welcome additions to the specification. Many of these features are already supported in major browsers, and the rest are soon to follow. By now, ECMAScript 2018 is in the works and I'm excited to see what proposals make it in!</p>
          </div>
        </div>
      </article>
    </main>

    <footer>
      <p>Jade Michael Thornton | <a href="https://jmthornton.net">Home</a> | <a href="https://gitlab.com/thornjad/jmthornton">Source code</a></p>
    </footer>

		<script class="matomo-analytics" type='text/javascript'>
		 var _paq = window._paq || [];
		 _paq.push(['setDocumentTitle', document.domain + ' -/- ' + document.title]);
		 _paq.push(['setDoNotTrack', true]);
		 _paq.push(['setCookieDomain', '*.jmthornton.net']);
		 _paq.push(['trackPageView']);
		 _paq.push(['enableLinkTracking']);
		 void function() {
			 var u='//jmthornton.net/analytics/';
			 _paq.push(['setTrackerUrl', u+'matomo.php']);
			 _paq.push(['setSiteId', '1']);
			 const d=document,
						 g=d.createElement('script'),
						 s=d.getElementsByTagName('script')[0];
			 g.type='text/javascript';
			 g.async=true;
			 g.defer=true;
			 g.src=u+'matomo.js';
			 s.parentNode.insertBefore(g,s);
		 }();
		</script>
    <script src="https://jmthornton.net/lib/trail.js" defer></script>
  </body>
</html>
