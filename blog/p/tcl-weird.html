<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>TCL Wat | Blog | Jade Michael Thornton</title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      type="text/plain"
      rel="author"
      href="https://jmthornton.net/humans.txt"
    />

    <meta name="robots" content="index, follow" />
    <meta name="googlebot" content="index, follow" />
    <meta
      name="google-site-verification"
      content="JUM1Dl9n9ic9xPMb03Nzf4NgW_-8PWZrJ4eJGC_PoYM"
    />
    <link
      rel="shortcut icon"
      href="https://jmthornton.net/assets/images/favicon.png"
    />
    <link
      rel="apple-itouch-icon"
      href="https://jmthornton.net/assets/images/favicon.ico"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-Regular.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-Italic.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-Bold.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-BoldItalic.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />

    <link
      href="/assets/vendor/prism.min.css"
      rel="stylesheet"
      media="(prefers-color-scheme: light)"
    />
    <link
      href="/assets/vendor/prism-dark.min.css"
      rel="stylesheet"
      media="(prefers-color-scheme: dark)"
    />
    <link rel="stylesheet" href="/assets/style/main.css" type="text/css" />

    <meta property="og:title" content="TCL Wat" />
    <meta
      name="description"
      content="A collection of weird TCL edge cases and gotchas I've encountered while working at FlightAware."
    />
    <meta property="og:url" content="https://jmthornton.net/blog/p/TCL-weird" />
    <meta property="og:site_name" content="jmthornton.net/blog" />
    <meta property="og:type" content="article" />
    <meta property="og:locale" content="en_US" />
    <meta name="article:author" content="https://jmthornton.net/blog" />
    <meta property="article:published_time" content="2020-04-10" />
  </head>
  <body>
    <header>
      <nav>
        <a href="/">Home</a>
        <a href="/now">Now</a>
        <a href="/blog">Blog</a>
        <a href="https://photos.jmthornton.net">Photos</a>
        <a href="https://emacs.jmthornton.net">Emacs</a>
      </nav>
    </header>

    <main>
      <article class="post blog-content">
        <h1 class="post-title">TCL Wat</h1>
        <time datetime="2020-04-10">April 10, 2020</time>

        <div class="post-main">
          <div class="blog-body">
            <p>
              At FlightAware, I read and write TCL every day. This means I've
              run into more than a few edge cases in the language, and have even
              tracked down a few bugs in
              <code class="language-tcl">TCLlib</code>. Here's a collection of
              the weirdest things I've encountered.
            </p>

            <h2>Empty string is a boolean superposition</h2>

            <p>
              In TCL, an empty string is regarded as both true and false, due to
              the language's dynamic typing and the way it handles truthy/falsy
              values. This can lead to unexpected behavior in conditionals:
            </p>

            <pre><code class="language-tcl">if {""} {
    puts "This is true"
} elseif {!""} {
    puts "This is false"
} else {
    puts "This is neither true nor false"
}</code></pre>

            <p>Output:</p>
            <pre><code>This is neither true nor false</code></pre>

            <p>
              Why is this the way it is? TCL treats empty strings as falsy in
              boolean contexts, but the empty string itself is still a valid
              string value. The negation
              <code class="language-tcl">!""</code> creates a boolean true, but
              the empty string in the
              <code class="language-tcl">if</code> condition is also falsy.
              It's... confusing.
            </p>

            <h2>Scalars are converted to dictionary keys</h2>

            <p>
              When using <code class="language-tcl">dict set</code> command to
              set a value into a dictionary, it can't automatically convert a
              scalar variable to a dictionary. You have to explicitly create a
              dictionary first:
            </p>

            <pre><code class="language-tcl">set my_dict [dict create]
dict set my_dict key value</code></pre>

            <p>
              This is actually reasonable behavior - TCL doesn't want to assume
              you meant to create a dict when you might have just made a typo.
              But it's still annoying when you forget.
            </p>

            <h2>Upvar and pass-by-name</h2>

            <p>
              <code class="language-tcl">upvar</code> is a command that
              introduces a new variable in the current context which is an alias
              for a variable in a caller's context. TCL uses pass-by-name for
              its argument passing, meaning the names of variables are passed,
              rather than their values:
            </p>

            <pre><code class="language-tcl">proc increment {varName} {
    upvar $varName var
    incr var
}

proc swap {a b} {
    upvar $a aVar $b bVar
    set temp $aVar
    set aVar $bVar
    set bVar $temp
}</code></pre>

            <p>
              This is actually pretty cool once you get used to it, but it's
              definitely not what you'd expect coming from other languages.
            </p>

            <h2>Insane string matching</h2>

            <p>
              Some TCL commands, like
              <code class="language-tcl">string is</code>, allow matching on
              shortened or abbreviated strings. While this can lead to concise
              code, it may also introduce unintended and interesting bugs:
            </p>

            <pre><code class="language-tcl">string is true true
# => 1
string is tru true
# => 1
string is tr true
# => 1
string is t true
# => 1
string is fa 0
# => 1</code></pre>

            <p>
              This has no practical benefit and serves only to create bugs. Why
              would a reasonable person ever want to check if a string "is tr"
              in production code?
            </p>

            <h2>Split nested list, get flat list</h2>

            <p>
              When using <code class="language-tcl">split</code> on a nested
              list, the result is a list with members representing the escaped
              syntax of the nested list(s):
            </p>

            <pre><code class="language-tcl">set a {aa bb {cc dd}}
split $a " "
# => {aa bb \{cc dd\}}</code></pre>

            <p>
              Notice that the braces of the nested list
              <code class="language-tcl">{cc dd}</code> have been escaped,
              resulting in a string that looks like a dict, but is not. This is
              because under the hood,
              <code class="language-tcl">split</code> operates on the string
              representation, not the list structure. This has been the source
              of a number of real bugs at FlightAware.
            </p>

            <h2>Lower-case numbers</h2>

            <p>
              The <code class="language-tcl">string tolower</code> command
              attempts to convert a string's characters to lowercase. When
              encountering mixed or non-alphabetic input, the results may be
              unexpected:
            </p>

            <pre><code class="language-tcl">set number_string "42A_B8C"
string tolower $number_string
# => 42a_b8c</code></pre>

            <p>
              Even though the numbers remain the same, the non-alphabetic
              characters have been modified. This is technically correct
              behavior, but it's weird that you can "lowercase" a number.
            </p>

            <h2>Dict loops don't garbage-collect</h2>

            <p>
              When using <code class="language-tcl">dict with</code> inside a
              loop, it overrides variables, but it doesn't automatically unset
              variables from previous iterations that have no new value:
            </p>

            <pre><code class="language-tcl">set data {
    item1 {var1 value1}
    item2 {var2 value2}
}

foreach item {item1 item2} {
    dict with data $item {
        puts "Item: $item, var1: $var1, var2: $var2"
    }
}</code></pre>

            <p>Output:</p>
            <pre><code>Item: item1, var1: value1, var2: value2
Item: item2, var1: value1, var2: value2</code></pre>

            <p>
              Notice that <code class="language-tcl">var1</code> is still set to
              <code class="language-tcl">value1</code> in the second iteration.
              The values were not garbage collected at the end of the
              <code class="language-tcl">dict with</code> body. This has been
              another real source of bugs.
            </p>

            <h2>Comments are not comments</h2>

            <p>
              In TCL, comments are technically commands that do nothing, the
              <code class="language-tcl">#</code> command, which is a no-op, to
              create comments:
            </p>

            <pre><code class="language-tcl"># This is a TCL comment</code></pre>

            <p>
              This means that comments can be placed anywhere a TCL command can
              go, but also that they are part of the evaluation process, albeit
              with no effect. It's... different.
            </p>

            <h2>Uplevel is OP</h2>

            <p>
              The <code class="language-tcl">uplevel</code> command is used to
              execute a script in a different scope or level. This can be useful
              in creating macros or DSLs (Domain Specific Languages) in TCL:
            </p>

            <pre><code class="language-tcl">proc print_doubled {script} {
    uplevel "set x [expr {$script * 2}] ; puts \$x"
}

print_doubled {2 + 3}
# => 10</code></pre>

            <p>
              This is actually pretty powerful, but it's also a great way to
              write code that nobody can understand or debug.
            </p>

            <h2>Lack of static typing</h2>

            <p>
              TCL is a dynamically typed language, which means variables don't
              have a fixed type. A variable can change its type during runtime:
            </p>

            <pre><code class="language-tcl">set my_var 42
puts "Variable type: [string is integer $my_var]"
# => Variable type: 1
set my_var "hello"
puts "Variable type: [string is integer $my_var]"
# => Variable type: 0</code></pre>

            <p>
              This can lead to flexibility in development, but may also cause
              unintended consequences or unexpected behavior. Especially when
              dealing with JSON or other structured data formats. On the
              surface, this behavior is expected because "everything is a
              string". But it causes bugs when you understand TCL well enough to
              know that nothing is a string at the fundamental level.
            </p>

            <h2>Subst is not a separate compilation step</h2>

            <p>
              In TCL, the <code class="language-tcl">subst</code> command is
              used to perform variable and command substitutions within strings.
              This can be handy in some situations, but it's important to note
              that <code class="language-tcl">subst</code> is executed at
              runtime:
            </p>

            <pre><code class="language-tcl">set x 10
set y "\$x + 5"
puts "Before substitution: $y"
# => Before substitution: $x + 5
puts "After substitution: [subst $y]"
# => After substitution: 10 + 5</code></pre>

            <p>
              This may be surprising if you're expecting TCL to
              <a href="https://philip.greenspun.com/tcl/introduction.adp"
                >act like a Lisp</a
              >, and means that you might miss syntax errors until the code is
              actually executed.
            </p>

            <h2>Two ways of catching errors</h2>

            <p>
              TCL provides error handling mechanisms via the
              <code class="language-tcl">catch</code>,
              <code class="language-tcl">try</code>, and
              <code class="language-tcl">error</code> commands:
            </p>

            <pre><code class="language-tcl">if {[catch {some_command} result]} {
    puts "Error encountered: $result"
}

try {
    some_command
} on error {errorMsg} {
    puts "Error encountered: $errorMsg"
}</code></pre>

            <p>
              The <code class="language-tcl">catch</code> command can be used to
              capture any errors or exceptions that occur within a script.
              <code class="language-tcl">try</code> and
              <code class="language-tcl">error</code> offer more sophisticated
              error handling, but they're still not as clean as exceptions in
              other languages.
            </p>

            <p>
              One particularly tricky aspect is that these error handling
              mechanisms will also set the
              <code class="language-tcl">errorCode</code> global variable, which
              can be both useful and a curse to debugging. When a TCL library
              function is the source of the error, this global can leak error
              state between different parts of your code, making it hard to
              track down where errors are actually coming from. It's especially
              problematic when functions use error handling as a way of checking
              for dictionary key existence.
            </p>

            <hr />

            <p>
              So there you have it - a collection of TCL weirdness that I
              encounter on a daily basis at FlightAware. Some of these are
              actually reasonable design decisions when you understand the
              philosophy behind TCL, but others are just... wat.
            </p>
          </div>
        </div>
      </article>
    </main>

    <footer>
      <p>
        Jade Michael Thornton | <a href="https://jmthornton.net">Home</a> |
        <a href="https://github.com/thornjad/jmthornton">Source code</a>
      </p>
    </footer>

    <script src="/assets/vendor/prism.js" defer></script>
  </body>
</html>
