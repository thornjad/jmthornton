<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>
      Data Paradigms in TCL: Associative Arrays vs Dictionaries | Blog | Jade
      Michael Thornton
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      type="text/plain"
      rel="author"
      href="https://jmthornton.net/humans.txt"
    />

    <meta name="robots" content="index, follow" />
    <meta name="googlebot" content="index, follow" />
    <meta
      name="google-site-verification"
      content="JUM1Dl9n9ic9xPMb03Nzf4NgW_-8PWZrJ4eJGC_PoYM"
    />
    <link
      rel="shortcut icon"
      href="https://jmthornton.net/assets/images/favicon.png"
    />
    <link
      rel="apple-itouch-icon"
      href="https://jmthornton.net/assets/images/favicon.ico"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-Regular.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-Italic.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-Bold.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="prefetch"
      href="https://jmthornton.net/assets/fonts/MetroNova-BoldItalic.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />

    <link
      href="/assets/vendor/prism.min.css"
      rel="stylesheet"
      media="(prefers-color-scheme: light)"
    />
    <link
      href="/assets/vendor/prism-dark.min.css"
      rel="stylesheet"
      media="(prefers-color-scheme: dark)"
    />
    <link rel="stylesheet" href="/assets/style/main.css" type="text/css" />

    <meta
      property="og:title"
      content="Data Paradigms in TCL: Associative Arrays vs Dictionaries"
    />
    <meta
      name="description"
      content="Understanding the fundamental differences between TCL's associative arrays and dictionaries, and when to use each."
    />
    <meta
      property="og:url"
      content="https://jmthornton.net/blog/p/TCL-paradigms"
    />
    <meta property="og:site_name" content="jmthornton.net/blog" />
    <meta property="og:type" content="article" />
    <meta property="og:locale" content="en_US" />
    <meta name="article:author" content="https://jmthornton.net/blog" />
    <meta property="article:published_time" content="2020-08-10" />
  </head>
  <body>
    <header>
      <nav>
        <a href="/">Home</a>
        <a href="/now">Now</a>
        <a href="/blog">Blog</a>
        <a href="https://photos.jmthornton.net">Photos</a>
        <a href="https://emacs.jmthornton.net">Emacs</a>
      </nav>
    </header>

    <main>
      <article class="post blog-content">
        <h1 class="post-title">
          Data Paradigms in TCL: Associative Arrays vs Dictionaries
        </h1>
        <time datetime="2020-08-10">August 10, 2020</time>

        <div class="post-main">
          <div class="blog-body">
            <p>
              Working with TCL for a while, you have to come to terms with the
              fact that arrays and dicts aren't just different APIs. They're
              fundamentally different beasts under the hood.
            </p>

            <h2>The Implementation Reality</h2>

            <p>
              Associative arrays are TCL's original key-value store, implemented
              as hash tables directly in the interpreter. When you write
              <code class="language-tcl">set arr(key) value</code>, you're
              actually creating a variable with a compound name. The interpreter
              maintains a separate hash table for each array variable, and
              accessing <code class="language-tcl">$arr(key)</code> triggers a
              hash lookup on that specific table.
            </p>

            <p>
              Dictionaries came later (TCL 8.5 in 2007) as first-class values.
              Unlike arrays, a dict is just a string with a specific internal
              representation: a list of alternating keys and values that gets
              cached as a hash table when you perform dict operations on it. The
              key insight is that dicts are values that can be passed around,
              while arrays are variables that live in specific scopes.
            </p>

            <h2>Why This Matters in Practice</h2>

            <p>
              Arrays tie you to variable scopes. You can't return an array from
              a procedure without using
              <code class="language-tcl">upvar</code> or
              <code class="language-tcl">global</code> to work around the
              limitation. Arrays also can't be nested without ugly naming tricks
              like <code class="language-tcl">set arr(outer,inner) value</code>.
            </p>

            <pre><code class="language-tcl"># Arrays: scope-bound and flat
proc make_config {} {
    # Can't return this directly
    set config(host) "localhost"
    set config(port) 8080
}

# Dicts: values you can actually use
proc make_config {} {
    return [dict create host localhost port 8080]
}</code></pre>

            <p>
              Dicts shine for structured data and functional-style programming.
              Need nested data?
              <code class="language-tcl"
                >dict set config database host localhost</code
              >
              just works. Want to pass complex data between procedures? Dicts
              are your friend.
            </p>

            <h2>Performance Quirks</h2>

            <p>
              Here's the counterintuitive part: arrays can be faster for simple
              key-value operations because there's no string parsing overhead
              (everything is a string, except when it's not). But dicts win for
              complex operations because they can optimize their internal
              representation and handle nesting efficiently.
            </p>

            <p>
              Arrays also support pattern matching with
              <code class="language-tcl">array names pattern</code>, which dicts
              can't match without iteration.
            </p>

            <h2>When to Use What</h2>

            <p>Use arrays for:</p>
            <ul>
              <li>Simple key-value stores that stay in one scope</li>
              <li>When you need pattern matching on keys</li>
              <li>Legacy code that expects array semantics</li>
            </ul>

            <p>Use dicts for:</p>
            <ul>
              <li>Structured, nested data</li>
              <li>Passing data between procedures</li>
              <li>Modern TCL code that values composability</li>
            </ul>

            <p>
              The real lesson? TCL's "everything is a string" philosophy is
              surface-level, and it means these data structures evolved
              different internal optimizations while maintaining the same
              string-based interface. At FlightAware, we've learned this the
              hard way. Legacy code is full of arrays that should have been
              dicts, and newer code sometimes uses dicts where arrays would be
              simpler. Understanding the implementation helps you pick the right
              tool and avoid performance traps.
            </p>
          </div>
        </div>
      </article>
    </main>

    <footer>
      <p>
        Jade Michael Thornton | <a href="https://jmthornton.net">Home</a> |
        <a href="https://github.com/thornjad/jmthornton">Source code</a>
      </p>
    </footer>

    <script src="/assets/vendor/prism.js" defer></script>
  </body>
</html>
