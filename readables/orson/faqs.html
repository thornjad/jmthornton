<!-- Created by Bracy 0.4 on Monday, January 1, 2018 at 7:06 PM CST -->
<html>
 <head>
  <title>
   FAQ's About Orson
  </title>
  <style>
   a:active
    { color: purple;
      font-weight: bold;
      text-decoration: none }
   a:link
    { color: blue;
      font-weight: bold;
      text-decoration: none }
   a:visited
    { color: purple;
      font-weight: bold;
      text-decoration: none }
   hr
    { background-color: black;
      border: none;
      color: black;
      height: 1px }
   table
    { border-collapse: collapse }
  </style>
 </head>
 <body bgcolor="#FFFFFF">
  <p align="center">
   <b>F<small>AQ</small>&rsquo;s About Orson</b>
   <br />
   <br />
   James B. Moen
   <br />
   September 4, 2017
  </p>
  <p align="justify">
   Copyright &#169; 2017 James B. Moen. Permission is granted to copy,
   distribute, and/or modify this document under the terms of the
   G<small>NU</small> Free Documentation License, Version 1.3 or any later
   version published by the Free Software Foundation; with no Invariant
   Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the
   license may be obtained at
   <a href="http://fsf.org/">
    <tt>&lt;http://fsf.org/&gt;.</tt>
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This document uses special characters.
   Without proper rendering support, you may see question marks, boxes, or
   other symbols in place of these characters. This document must be rendered
   using a font where a quote &lsquo;&nbsp;"&nbsp;&rsquo;, an italic quote
   &lsquo;&nbsp;<i>"</i>&nbsp;&rsquo;, and two apostrophes
   &lsquo;&nbsp;''&nbsp;&rsquo; all look different.
  </p>
  <hr />
  <p>
   <b>0. Introduction.</b>
  </p>
  <blockquote>
   <p align="justify">
    F<small>AQ</small>: Free at Quay.
   </p>
   <p align="right">
    <a href="#des1967">
     [<small>DES</small> 1967]
    </a>
   </p>
  </blockquote>
  <p align="justify">
   F<small>AQ</small>&rsquo;s are Frequently Asked Questions, but since no
   one asks questions about Orson, these are Fictionally Anticipated Questions
   instead.
  </p>
  <blockquote>
   <table cellpadding="0" cellspacing="0">
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#general">
        1.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       General questions.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#arraytups">
        2.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about arrays and tuples.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#chars">
        3.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about characters.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#coercions">
        4.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about coercions.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#constvars">
        5.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about constants and variables.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#equates">
        6.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about equates and declarations.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#forms">
        7.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about forms.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#parens">
        8.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about parentheses.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#pointers">
        9.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about pointers.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#string">
        10.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about strings.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#tokens">
        11.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about tokens.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#types">
        12.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about types.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#current">
        13.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Questions about the current implementation of Orson.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#misc">
        14.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       Miscellaneous questions.
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p align="right">
       <a href="#references">
        15.
       </a>
       &nbsp;
      </p>
     </td>
     <td>
      <p>
       References.
      </p>
     </td>
    </tr>
   </table>
  </blockquote>
  <p align="justify">
   Some of these questions were suggested by the <small>FAQ</small> lists
   for other languages, notably those for C. I may add new questions to the
   list from time to time.
  </p>
  <hr />
  <a name="general">
  </a>
  <p>
   <b>1. General questions.</b>
  </p>
  <p align="justify">
   <b>Q.</b> What is Orson?
  </p>
  <p align="justify">
   <b>A.</b> <i>Orson</i> is a small, general purpose programming
   language. It&rsquo;s designed to be used by individuals instead of groups,
   so it omits the complex information hiding mechanisms of other languages,
   like classes, modules, and packages. In their place, Orson emphasizes
   extendability and expressiveness, and provides access to low level objects
   like that of C
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
   However, you can still write safe, modular programs in Orson.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson divides computation into two phases,
   called <i>transformation</i> and <i>execution.</i> In
   transformation, Orson creates new expressions by calling <i>forms,</i>
   which are much like macros that expand to abstract syntax trees. Forms are
   written in an applicative language that is similar to Scheme, but with an
   algebraic notation and an explicit type system. In execution, Orson
   evaluates the expressions produced by transformation, as in a conventional
   compiler.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Although the parts of Orson that perform
   transformation and execution are tightly integrated, the language may be
   implemented so that all transformations are performed at compile time, and
   all executions at run time. This allows programming with forms in an
   abstract, general style, while still producing efficiently executable
   programs.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson consists of a <i>kernel</i> that
   provides control structures, and a <i>prelude</i> that provides
   operators and types. The prelude is written in Orson, and many different
   preludes may be used with the same kernel. It is therefore possible to
   implement new versions of Orson simply by writing new preludes.
  </p>
  <p align="justify">
   <b>Q.</b> Why is it called <i>Orson</i>?
  </p>
  <p align="justify">
   <b>A.</b> I thought the name sounded good. <i>Orson</i>
   isn&rsquo;t an acronym, so it doesn&rsquo;t properly appear in capital
   letters. The name doesn&rsquo;t refer to any group, person, place, or thing:
   Orson is not named after Orson Bean, Orson Scott Card, or Orson Welles.
   Orson also has nothing to do with the <small>BRIT</small>-award-winning
   rock band (1999&#8211;2008) of the same name.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Since Orson uses forms so much, I once
   considered calling it <i>Formula,</i> as a pun on <i>Modula</i>
   (which uses modules) and <i>Simula</i> (which does simulations). Alas,
   someone else had already used the name for a music composition language
   <a href="#and1991">
    [<small>AND</small> 1991].
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A very early version of Orson was called
   <i>Who,</i> intended as a joking reference to the many languages that
   are named after famous people (like <i>Ada, Eiffel, Haskell,</i> and
   <i>Pascal</i>). However, this presented obvious problems with what to
   call the compiler in a Unix environment, as the names <tt>who</tt> and
   <tt>wc</tt> are already taken.
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t Orson look like C? All the other new
   languages do.
  </p>
  <p align="justify">
   <b>A.</b> C&rsquo;s syntax is badly designed. For example, consider (1)
   the need for semicolons as terminators for some (but not all) statements,
   (2) the error-prone infix operators, such as &lsquo;=&rsquo; and
   &lsquo;==&rsquo;, (3) the inside-out notation for function types, (4) the
   bizarre infix operator priorities, (5) the need for <i>break</i>
   statements inside <i>switch</i> statements, (6) the lack of delimiting
   names like <b>then</b> and <b>of,</b> whose presence promotes
   readability and good error recovery.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C is great because of its
   <i>semantics,</i> not its syntax. Designers of new programming
   languages haven&rsquo;t understood this, because they&rsquo;ve imitated its
   syntax, not its semantics. Perhaps they think making their languages look
   like C will make them easier to learn. This is a mistake, because learning a
   new syntax is only a small part of learning a new language. It also misleads
   new users. I often meet people who know C++
   <a href="#str1994">
    [<small>STR</small> 1994]
   </a>
   , but think they know Java
   <a href="#gos1996">
    [<small>GOS</small> 1996]
   </a>
   or vice-versa, because the two languages look so much alike.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson doesn&rsquo;t look like C because
   it&rsquo;s different from C. C is a statement language; Orson is an
   expression language. C uses name compatibility for some of its types; Orson
   uses structure compatibility. C programs are collections of functions; most
   Orson programs are collections of forms. C doesn&rsquo;t really have arrays;
   Orson does.
  </p>
  <p align="justify">
   <b>Q.</b> Why isn&rsquo;t Orson object oriented? All the other new
   languages are.
  </p>
  <p align="justify">
   <b>A.</b> In the 1960&rsquo;s, some programmers thought you
   couldn&rsquo;t use linked data structures without using someone&rsquo;s
   fancy list processing system, like <small>IPL</small>
   <a href="#sam1969">
    [<small>SAM</small> 1969]
   </a>
   or Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990].
   </a>
   Knuth&rsquo;s books debunked this idea
   <a href="#knu1975">
    [<small>KNU</small> 1975].
   </a>
   Of course you can use linked structures in any modern language.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now programmers think you can&rsquo;t write
   in an object oriented style without using someone&rsquo;s fancy object
   oriented system, like C++ or Java. Actually you can approximate an object
   oriented style in any modern language. Orson contains several mechanisms
   (alternate forms and secret names) that support such approximations.
   <i>Objects may be closer than they appear!</i>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I&rsquo;m skeptical about object
   orientedness. It works well for games, graphics, and
   <small>GUI</small>&rsquo;s (the three <small>G</small>&rsquo;s).
   However, it works less well for other kinds of programs, in which it may
   make simple things unnecessarily complicated. Maybe someday, object oriented
   programming will go back into our bag of tricks along with everything else,
   to be taken out and used only when appropriate.
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson come with an <small>IDE</small>? All the
   other new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Not at present. Of course an <small>IDE</small> is an
   Integrated Development Environment, essentially a text editor that automates
   the troublesome tasks of programming. Orson doesn&rsquo;t have one because I
   don&rsquo;t use <small>IDE</small>&rsquo;s when I write programs. I use
   Emacs and G<small>NU</small> shell commands instead. I don&rsquo;t know
   if it would be possible to take an existing <small>IDE</small> and
   adapt it to Orson, or vice-versa.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A lot of people want to make badly designed
   programming languages easier to use by giving them fancy
   <small>IDE</small>&rsquo;s. This makes sense if you are forced to use a
   badly designed language. I think it would be better to try making well
   designed languages instead. I don&rsquo;t know if Orson is well designed or
   not.
  </p>
  <p align="justify">
   <b>Q.</b> Why isn&rsquo;t Orson an interpreted language? All the other
   new languages are.
  </p>
  <p align="justify">
   <b>A.</b> There&rsquo;s a place for interpreted languages.
   They&rsquo;re good for fast prototyping and for portability. Also, the speed
   of compiled languages isn&rsquo;t needed for many applications. Some people
   therefore argue that programming ought to be done exclusively with
   interpreters. At the risk of attacking a straw man, I think this is a bad
   idea.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Using interpreted languages means we
   don&rsquo;t benefit from faster hardware. My present computer is many times
   faster than the one I owned in the 1980&rsquo;s, and it has far more memory.
   But my interpreted programs now seem to run about as fast as my compiled
   programs did back then, and they&rsquo;re not that much easier to write.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interpreted languages also prevent
   programmers from accessing the hardware directly. Here&rsquo;s a paranoid
   fantasy: suppose a big operating systems company wished to prevent
   competition. It might then support only interpreted languages that
   aren&rsquo;t powerful enough to write new operating systems. This would make
   it hard for small companies to rise up and challenge them. Now imagine what
   would happen if this company also held a monopoly on all software available
   to the public...
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson have a garbage collector? All the other new
   languages do.
  </p>
  <p align="justify">
   <b>A.</b> Yes. The Orson library provides a way to automatically
   garbage collect unused objects. It uses a mark-sweep garbage collector,
   using the Schorr-Waite stackless traversal algorithm
   <a href="#sch1967">
    [<small>SCH</small> 1967],
   </a>
   and the Weinstock-Wulf &lsquo;&lsquo;quick fit&rsquo;&rsquo; algorithm
   <a href="#wei1988">
    [<small>WEI</small> 1988],
   </a>
   which is optimized for allocating large numbers of small objects. Also,
   it&rsquo;s a real garbage collector that can reclaim all unused objects, not
   just a conservative garbage collector that may leave some of them in place.
   Like other things called &lsquo;&lsquo;conservative,&rsquo;&rsquo;
   conservative garbage collectors don&rsquo;t always work.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you don&rsquo;t like the garbage collector
   from Orson&rsquo;s library, then you can write your own. Orson provides an
   iterator called <i>refs</i> that visits all base pointers in your
   program. You can use <i>refs</i> as a starting point for implementing
   many different garbage collection algorithms.
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson support concurrency, parallel computation,
   multi-processing, or threads? All the other new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Not at present. Future versions may do so. It may be possible
   to use <small>POSIX</small> threads
   <a href="#stv2005">
    [<small>STV</small> 2005]
   </a>
   with the current Orson compiler, but there&rsquo;s no explicit support for
   this, and I&rsquo;ve never tried it. Orson&rsquo;s catch-throw mechanism and
   the garbage collector in the Orson library are probably not safe for
   threads.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson is currently translated to
   G<small>NU</small> C, so it&rsquo;s possible to do anything in Orson
   that can be done in that language. For example, you can create new processes
   by calling the C function <tt>fork</tt>
   <a href="#stv2005">
    [<small>STV</small> 2005].
   </a>
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson have a formally defined semantics? All the other
   new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Not at present. Why? (1) I wanted to describe Orson in a way
   that would be accessible to a wide audience, so I wrote most of the
   Revised&#8315;&#185; Report
   <a href="#moe2017">
    [<small>MOE</small> 2017]
   </a>
   in English instead of mathematics. However, Orson&rsquo;s type system is
   still described using a semi-formal notation. (2) All the Orson
   documentation is in <small>HTML</small>
   <a href="#pow2001">
    [<small>POW</small> 2001]
   </a>
   so it can be read with a browser, but browsers can&rsquo;t display
   mathematics well enough to handle the typography of formal semantics. (3) I
   don&rsquo;t know enough about formal semantics to describe Orson. This is
   the real reason.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I&rsquo;d be happy to hear from anyone who
   wants to write a formal semantics for Orson, or from anyone who has already
   done so. I don&rsquo;t guarantee that I can help you write such a thing, or
   even that I&rsquo;ll understand it after you&rsquo;re written it.
  </p>
  <p align="justify">
   <b>Q.</b> Orson sucks. No one will use Orson instead of Whatgol (insert
   your favorite language).
  </p>
  <p align="justify">
   <b>A.</b> No one has to. I didn&rsquo;t write Orson to replace any
   other language, and to paraphrase Dr. Frank N. Furter in <i>The Rocky
   Horror Picture Show</i>
   <a href="#hen1979">
    [<small>HEN</small> 1979],
   </a>
   I didn&rsquo;t write it for you. I wrote it because I wanted to use it
   myself. Many people think something must be popular to be successful. This
   is the high school cheerleader&rsquo;s definition of success. Don&rsquo;t be
   misled by it.
  </p>
  <p align="justify">
   <b>Q.</b> Orson sucks. I can&rsquo;t use it to make web pages that talk
   to databases (insert your favorite commercial programming task).
  </p>
  <p align="justify">
   <b>A.</b> Orson is a low level language with a high level library. You
   might be able to write Orson programs like the ones you want if there was
   library support for them. I didn&rsquo;t provide such support, because I
   didn&rsquo;t design Orson for commercial programming. If you already have a
   language that does what you want, then why are you reading about Orson?
  </p>
  <hr />
  <a name="arraytups">
  </a>
  <p>
   <b>2. Questions about arrays and tuples.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Is there a way to compare arrays or tuples automatically?
  </p>
  <p align="justify">
   <b>A.</b> No. The only way to do that is to write a form or procedure
   that compares two arrays element by element, or two tuples slot by slot.
   However, you can write a higher-order form that makes a comparison form
   automatically, like this.
  </p>
  <blockquote>
   <p>
    <i>makeEquality</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<b>type</b>&nbsp;<i>tup</i>&nbsp;<i>t</i>,&nbsp;<i>list</i>&nbsp;<i>s</i>)&nbsp;<i>foj</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>form</b>&nbsp;(<i>t</i>&nbsp;<i>l</i>,&nbsp;<i>t</i>&nbsp;<i>r</i>)&nbsp;<i>bool</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b></font><i>makingEquality</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i></font>(<b>form</b>&nbsp;(<i>list</i>&nbsp;<i>s</i>)&nbsp;<i>bool</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i>(</font>(<b>if</b>&nbsp;<i>isEmpty</i>(<i>s</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i>((</font><b>then</b>&nbsp;<i>true</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((<b>w</b><i>m</i>((</font><b>else</b>&nbsp;<i>"</i>.<i>"</i>(<i>l</i>,&nbsp;<i>car</i>(<i>s</i>))&nbsp;=&nbsp;<i>"</i>.<i>"</i>(<i>r</i>,&nbsp;<i>car</i>(<i>s</i>))&nbsp;&#8743;&nbsp;<i>makingEquality</i>(<i>cdr</i>(<i>s</i>))))&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(((</font><b>do</b>&nbsp;<i>makingEquality</i>(<i>s</i>))))&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>
    <br />
    <i>comp</i>&nbsp;:&#8722;&nbsp;(<b>tuple</b>&nbsp;<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>
    <br />
    <i>"</i>=<i>"</i>&nbsp;:&#8722;&nbsp;<i>makeEquality</i>(<i>comp</i>:&nbsp;$<i>re</i>,&nbsp;$<i>im</i>)
   </p>
  </blockquote>
  <p align="justify">
   This is one of the few times when you must call <i>"</i>.<i>"</i>
   explicitly, instead of writing <i>e</i>.<i>n.</i>
  </p>
  <p align="justify">
   <b>Q.</b> Can I write a constant whose type is an array or a tuple?
  </p>
  <p align="justify">
   <b>A.</b> No. But you can simulate such a thing by calling a form or a
   procedure. For example, a call to the form <i>makeCom</i> returns a
   complex number, represented as an instance of the tuple type
   <i>com.</i>
  </p>
  <blockquote>
   <p>
    <i>com</i>&nbsp;:&#8722;&nbsp;(<b>tuple</b>&nbsp;<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>
    <br />
    <i>makeCom</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;<i>com</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>com</i>&nbsp;<i>z</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font><b>do</b>&nbsp;<i>z</i>.<i>re</i>&nbsp;:=&nbsp;<i>re</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((<b>do</b>&nbsp;</font><i>z</i>.<i>im</i>&nbsp;:=&nbsp;<i>im</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((<b>do</b>&nbsp;</font><i>z</i>))
   </p>
  </blockquote>
  <p align="justify">
   Orson doesn&rsquo;t have a notation for array or tuple constants because
   it&rsquo;s easy to write forms like this. The Orson library may someday
   provide versions of such forms whose calls transform to actual constants.
  </p>
  <hr />
  <a name="chars">
  </a>
  <p>
   <b>3. Questions about characters.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Does Orson support Unicode? All the other new languages do.
  </p>
  <p align="justify">
   <b>A.</b> Yes. Orson uses a 31-bit character set that includes the
   21-bit Unicode
   <a href="#uni2006">
    [<small>UNI</small> 2006]
   </a>
   and the 7-bit <small>ASCII</small>
   <a href="#ans1986">
    [<small>ANS</small> 1986]
   </a>
   character sets as subsets. (Some people think Unicode is a 16-bit character
   set, but they&rsquo;re wrong.) Orson uses the <small>UTF</small>-8
   encoding for strings and source files.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The good news is that you can still write
   Orson programs in <small>ASCII</small>, even on old systems that
   don&rsquo;t support Unicode, and that Orson characters and strings are
   completely compatible with those of C
   <a href="#ker1988">
    [<small>KER</small> 1988]
   </a>
   and Unix
   <a href="#stv2005">
    [<small>STV</small> 2005].
   </a>
   The bad news is that you can&rsquo;t traverse <small>UTF</small>-8
   strings by simple pointer arithmetic. However, the Orson library has forms
   that make this relatively painless.
  </p>
  <p align="justify">
   <b>Q.</b> How can Orson use a 31-bit character set, when Unicode has
   only 21-bit characters? What are the other characters?
  </p>
  <p align="justify">
   <b>A.</b> Orson uses 31-bit characters, but only those in the 21-bit
   Unicode set are defined. However, you can still use characters from outside
   the Unicode set in your programs. For example, your programs can put them
   into <small>UTF</small>-8 strings, they can read them from
   <small>UTF</small>-8 text files, and they can write them to
   <small>UTF</small>-8 text files. This is intended to support future
   expansions of Unicode, should they ever occur.
  </p>
  <p align="justify">
   <b>Q.</b> The Orson character types <i>char</i>0 and
   <i>char</i>1 are signed, so character codes can be negative. How can
   characters have negative codes?
  </p>
  <p align="justify">
   <b>A.</b> They can&rsquo;t. Negative codes don&rsquo;t represent
   characters. However, you can still use negative character codes in your
   programs if you want, although they can&rsquo;t be in
   <small>UTF</small>-8 strings or text files. Characters with negative
   codes might be used internally by Orson programs to denote illegal
   characters, to encode extra bits into characters, etc.
  </p>
  <p align="justify">
   <b>Q.</b> If Orson supports Unicode, then why can&rsquo;t I use
   Cyrillic letters in names, like I can in Java? (Insert your favorite
   non-Roman alphabet.)
  </p>
  <p align="justify">
   <b>A.</b> In plain and secret names, Orson allows only (1) unaccented
   Roman letters, (2) unaccented Greek letters that don&rsquo;t look like Roman
   letters, and (3) a few mathematical symbols. There are two reasons why.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First, most programming languages use English
   reserved names (like <b>if</b> and <b>while</b>), and their
   syntaxes are based on English grammar. They can&rsquo;t be made
   international just by allowing unreserved names to use letters from multiple
   alphabets.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second, programs should be written to be as
   understood by as many people as possible. It&rsquo;s claimed that more
   people read English than any other language
   <a href="#mcc1987">
    [<small>MCC</small> 1987],
   </a>
   and all programmers know some mathematics. As a result, programs should be
   written with English or mathematical names. For example, Linus Torvalds, a
   native of Finland whose first language is Swedish, wrote his famous
   operating system kernel in English
   <a href="#moo2001">
    [<small>MOO</small> 2001].
   </a>
   No chauvinism is intended: the status of English is due to historical
   accidents, not to any inherent superiority.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson does allow most characters (including
   those from non-Roman alphabets) in quoted names. For example, you can write
   <i>"</i>&#1056;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;<i>"</i>
   in Cyrillic letters, but you must include the quotes, since they&rsquo;re
   part of the name.
  </p>
  <p align="justify">
   <b>Q.</b> I just tried to write an Orson program, but the compiler
   complained when I used tabs. How can I make it stop doing that?
  </p>
  <p align="justify">
   <b>A.</b> Don&rsquo;t use tabs. They&rsquo;re handled inconsistently by
   output devices and utility programs. A program with tabs might look properly
   indented on one computer, but not on another. This can&rsquo;t happen if you
   use blanks, which look the same way everywhere. Orson makes you use blanks
   by treating tabs (and all other control characters except newlines) as
   illegal characters.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Just because you shouldn&rsquo;t use tabs,
   doesn&rsquo;t mean you shouldn&rsquo;t use the <small>TAB</small> key.
   Some text editors can insert an appropriate number of blanks when you press
   <small>TAB</small>. Consider using such an editor.
  </p>
  <hr />
  <a name="coercions">
  </a>
  <p>
   <b>4. Questions about coercions.</b>
  </p>
  <p align="justify">
   <b>Q.</b> When I write the equate
   <b>real</b>&nbsp;<i>x</i>&nbsp;:&#8722;&nbsp;0, I get an error
   message. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> 0 isn&rsquo;t a real constant. It&rsquo;s an integer
   constant. Unlike other languages, Orson doesn&rsquo;t automatically coerce
   integers to reals. Write
   <b>real</b>&nbsp;<i>x</i>&nbsp;:&#8722;&nbsp;0.0 instead. Orson
   has only the bare minimum of coercions, and no way to define new ones.
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t Orson coerce integers to reals? All the
   other languages do.
  </p>
  <p align="justify">
   <b>A.</b> There are several reasons.
  </p>
  <ul>
   <li>
   <p align="justify">
    Coercion should occur only in situations where no information will be lost.
    On most computers, some integers cannot be exactly represented as reals, so
    information would be lost if they were coerced.
   </p>
   <li>
   <p align="justify">
    Integers and reals are very different kinds of objects inside a computer,
    and have different properties. For example, it is meaningful to test
    integers for equality, but in many algorithms it is not meaningful to test
    reals for equality. Often you test if they are within some small number
    &#949; of each other, by writing
    <i>abs</i>(<i>u</i>&nbsp;&#8722;&nbsp;<i>v</i>)&nbsp;&#8804;&nbsp;&#949;.
   </p>
   <li>
   <p align="justify">
    Suppose that Orson coerced integers to reals, and then someone implemented
    complex numbers, perhaps by using tuples. Then for consistency, there
    should be a way to coerce reals to complexes, too. That would require a
    user-defined coercion mechanism, something which would complicate Orson
    tremendously. (An early version of Orson had this: it was a mess.) The
    simplest fix, which maintains consistency, is not to coerce integers to
    reals.
   </p>
   <li>
   <p align="justify">
    Coercions from integers to reals can be simulated easily by casts. Using an
    explicit cast alerts the reader when an object of one type is converted to
    an object of another type, which an implicit coercion doesn&rsquo;t do.
    Also, it&rsquo;s possible to define new casts.
   </p>
  </ul>
  <p align="justify">
   Coercions complicate a language tremendously. The baroque coercions of Algol
   68
   <a href="#vwi1977">
    [<small>VWI</small> 1977]
   </a>
   were perhaps the reason for its unpopularity and eventual demise. I tried to
   avoid these problems by designing Orson with the minimum possible number of
   coercions.
  </p>
  <p align="justify">
   <b>Q.</b> But Orson coerces characters to integers, and it also coerces
   pointers. Why does it do that?
  </p>
  <p align="justify">
   <b>A.</b> Because no information is lost by those coercions, and
   because they don&rsquo;t complicate the type system much. Also, characters
   and integers are represented internally in the same way.
  </p>
  <hr />
  <a name="constvars">
  </a>
  <p>
   <b>5. Questions about constants and variables.</b>
  </p>
  <p align="justify">
   <b>Q.</b> I declared an integer variable <i>j</i> with an initial
   value of 0. When I tried resetting <i>j</i> to 4, I got an error
   message about an undefined method.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    (<b>with</b>&nbsp;<i>int</i>&nbsp;<i>j</i>&nbsp;:&#8722;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>do</b>&nbsp;<i>j</i>&nbsp;:=&nbsp;2&nbsp;+&nbsp;2&nbsp;
    <br />
    <font color="#FFFFFF">(<b>do</b>&nbsp;</font><i>writeln</i>(<i>j</i>))
   </p>
  </blockquote>
  <p align="justify">
   What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> The name <i>j</i> isn&rsquo;t a variable. It&rsquo;s a
   constant. You got an error message because the form
   <i>"</i>:=<i>"</i> expects a variable as its first argument, but
   you gave it a constant instead. Orson searched for a member of
   <i>"</i>:=<i>"</i> that works with constants, but it
   couldn&rsquo;t find one, so it scolded you about an undefined method. You
   should have written this.
  </p>
  <blockquote>
   <p>
    (<b>with</b>&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>j</i>&nbsp;:&#8722;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>do</b>&nbsp;<i>j</i>&nbsp;:=&nbsp;2&nbsp;+&nbsp;2&nbsp;
    <br />
    <font color="#FFFFFF">(<b>do</b>&nbsp;</font><i>writeln</i>(<i>j</i>))
   </p>
  </blockquote>
  <p align="justify">
   Orson is fussier than other languages about distinguishing constants and
   variables. This lets it do computation with constants during transformation.
   Variable types have <b>var</b> prefixes. Constant types don&rsquo;t.
  </p>
  <p align="justify">
   <b>Q.</b> When I wrote this, I got an error message about
   <i>"</i>:=<i>"</i> being an undefined method.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>then</b>&nbsp;<i>x</i>&nbsp;:=&nbsp;&#8722;&nbsp;<i>x</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font><i>x</i>)
   </p>
  </blockquote>
  <p align="justify">
   What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> The name <i>x</i> isn&rsquo;t a variable. It&rsquo;s a
   constant. You got an error message because the form
   <i>"</i>:=<i>"</i> expects a variable as its first argument, but
   you gave it a constant instead. Orson searched for a member of
   <i>"</i>:=<i>"</i> that works with constants, but it
   couldn&rsquo;t find one, so it scolded you about an undefined method. You
   could have written this, which makes a local variable <i>x</i> and
   initializes it to the value of the parameter <i>x.</i>
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>x</i>&nbsp;:&#8722;&nbsp;(<b>past</b>&nbsp;<i>x</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>do</b>&nbsp;(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((<b>do</b>&nbsp;(</font><b>then</b>&nbsp;<i>x</i>&nbsp;:=&nbsp;&#8722;&nbsp;<i>x</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((<b>do</b>&nbsp;</font><i>x</i>))
   </p>
  </blockquote>
  <p align="justify">
   However, it&rsquo;s simpler to write it without variables, like this. Orson
   often uses variables less than other languages.
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>else</b>&nbsp;<i>x</i>))
   </p>
  </blockquote>
  <p align="justify">
   Some programmers like to represent the state of a program using the values
   of variables. They write their code as a linear series of steps, where each
   step changes the program&rsquo;s state by resetting the variables. Call this
   &rsquo;&rsquo;state as value.&rsquo;&rsquo;
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Other programmers like to represent state
   using the place that&rsquo;s currently being executed in a program. They
   write their code as a branching structure instead, with a different place
   for each state that their program can assume. Call this &rsquo;&rsquo;state
   as place.&rsquo;&rsquo;
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I personally prefer to write in the
   &lsquo;&lsquo;state as place&rsquo;&rsquo; style whenever possible, because
   I think it&rsquo;s easier to read and understand. It&rsquo;s also closer to
   the &lsquo;&lsquo;spirit&rsquo;&rsquo; of Orson, whose design steals ideas
   from languages that use variables sparingly or not at all.
  </p>
  <p align="justify">
   <b>Q.</b> I want to declare a variable <i>v</i> whose value can be
   an integer of any type. I wrote the equate
   <b>var</b>&nbsp;<i>inj</i>&nbsp;<i>v,</i> but Orson gave me
   an error message about a missing &lsquo;:&#8722;&rsquo;. So I wrote the
   equate
   <b>var</b>&nbsp;<i>inj</i>&nbsp;<i>v</i>&nbsp;:&#8722;&nbsp;0
   instead, but then Orson gave me an error message about 0 having the wrong
   type. How can I declare a variable of type
   <b>var</b>&nbsp;<i>inj</i>?
  </p>
  <p align="justify">
   <b>A.</b> You can&rsquo;t declare a variable of type
   <b>var</b>&nbsp;<i>inj,</i> or indeed any variable whose base type
   contains jokers. This is because variables are pure execution objects (they
   exist only during execution) but jokers are pure transformation objects
   (they exist only during transformation). I admit the error messages are
   misleading, but they are correctly saying that you can&rsquo;t do what
   you&rsquo;re trying to do.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are infinitely many possible integer
   types: <i>int</i>0, <i>int</i>1, <i>int</i>2, etc., with
   increasing sizes. A variable whose value is an integer of any type would
   have an infinitely large size, and so couldn&rsquo;t be represented by a
   real computer. You might be able to approximate what you want by using a
   variable of type
   <b>var</b>&nbsp;<i>high</i>(<b>type</b>&nbsp;<i>inj</i>),
   whose base type is the largest available integer type.
  </p>
  <p align="justify">
   <b>Q.</b> If I can&rsquo;t declare a variable of type
   <b>var</b>&nbsp;<i>inj,</i> then what good is the type
   <b>var</b>&nbsp;<i>inj</i>? Why does Orson even let me write such
   a type?
  </p>
  <p align="justify">
   <b>A.</b> There are no objects whose type is <i>exactly</i>
   <b>var</b>&nbsp;<i>inj.</i> However, there are objects whose types
   are <i>subtypes</i> of <b>var</b>&nbsp;<i>inj.</i> For
   example, a <b>var</b>&nbsp;<i>int</i>0 variable has a type that is
   a subtype of <b>var</b>&nbsp;<i>inj.</i> As a result, a type like
   <b>var</b>&nbsp;<i>inj</i> can be used in situations where you
   want to <i>describe</i> an existing object, not <i>make</i> a new
   object. For example, you can write a form <i>zeroer</i> that takes an
   integer variable of any size as its argument, and sets its value to 0.
  </p>
  <blockquote>
   <p>
    <i>zeroer</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>z</i></font>(<b>form</b>&nbsp;(<b>var</b>&nbsp;<i>inj</i>&nbsp;<i>v</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>z</i>(<b>f</b></font><i>v</i>&nbsp;:=&nbsp;0)
   </p>
  </blockquote>
  <p align="justify">
   Here <b>var</b>&nbsp;<i>inj</i> is simply describing the objects
   to which <i>v</i> can be bound. It says that <i>v</i> can be bound
   to a variable of type <b>var</b>&nbsp;<i>int</i>0, or of type
   <b>var</b>&nbsp;<i>int</i>1, or of type
   <b>var</b>&nbsp;<i>int</i>2, etc.
  </p>
  <p align="justify">
   <b>Q.</b> But doesn&rsquo;t <i>v</i> have the type
   <b>var</b>&nbsp;<i>inj</i> inside the body of the form
   <i>zeroer</i>?
  </p>
  <p align="justify">
   <b>A.</b> No, it has the type of the constant or expression with which
   <i>zeroer</i> was called. If <i>zeroer</i> is called with an
   expression of type <b>var</b>&nbsp;<i>int</i>0, then <i>v</i>
   has the type <b>var</b>&nbsp;<i>int</i>0, and if it&rsquo;s called
   with an expression of type <b>var</b>&nbsp;<i>int</i>1, then it
   has the type <b>var</b>&nbsp;<i>int</i>1 instead. Arguments to
   forms are coerced to <i>subtypes</i> of their corresponding parameter
   types, not necessarily to <i>exactly</i> those parameter types. The
   Revised&#8315;&#185; Report
   <a href="#moe2017">
    [<small>MOE</small> 2017]
   </a>
   calls this <i>permissive coercion.</i>
  </p>
  <hr />
  <a name="equates">
  </a>
  <p>
   <b>6. Questions about equates and declarations.</b>
  </p>
  <p align="justify">
   <b>Q.</b> How do I declare a variable whose value is a procedure?
  </p>
  <p align="justify">
   <b>A.</b> Write the equate
   <b>var</b>&nbsp;<i>p</i>&nbsp;<i>n</i>&nbsp;:&#8722;&nbsp;<i>e,</i>
   where <i>p</i> is the type of the procedure you want, <i>n</i> is
   the name of the variable, and <i>e</i> is an expression that returns a
   procedure of type <i>p.</i> You can write
   <b>var</b>&nbsp;<i>p</i>&nbsp;<i>n</i> if you want to
   initialize <i>n</i> later. For example, if you want a variable whose
   values are procedures that take integer arguments and return integers, then
   you&rsquo;d write
   <b>var</b>&nbsp;<b>proc</b>&nbsp;(<i>int</i>)&nbsp;<i>int</i>&nbsp;<i>n.</i>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Don&rsquo;t use a pointer to a procedure as
   you would in C
   <a href="#ker1988">
    [<small>KER</small> 1988],
   </a>
   unless you&rsquo;re doing something weird. If you do that, then you&rsquo;ll
   get something that Orson thinks is different from a procedure itself. But
   see the next question.
  </p>
  <p align="justify">
   <b>Q.</b> How can I declare a procedure that returns a procedure of the
   same type? I&rsquo;m building a state machine with one procedure for each
   state, each of which returns a procedure for the next state. But I
   can&rsquo;t find a way to declare the procedures.
  </p>
  <p align="justify">
   <b>A.</b> You can&rsquo;t, but you can have the procedure return a
   pointer to a procedure of the same type. This is what I meant by
   &lsquo;&lsquo;something weird&rsquo;&rsquo; in the previous question. For
   example:
  </p>
  <blockquote>
   <p>
    <i>state</i>&nbsp;:&#8722;&nbsp;<b>proc</b>&nbsp;()&nbsp;<b>ref</b>&nbsp;<i>state</i>&nbsp;
    <br />
    <i>nextState</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>proc</b>&nbsp;()&nbsp;<b>ref</b>&nbsp;<i>state</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(<b>p</b></font>...)
   </p>
  </blockquote>
  <p align="justify">
   You&rsquo;d then dereference the pointer to get the procedure. This is one
   of the few places where you really need a pointer to a procedure. I assume
   you want procedures that don&rsquo;t accept arguments, but it&rsquo;s easy
   to modify the above procedures so they do.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If <i>p</i> is a pointer to a procedure
   that doesn&rsquo;t accept arguments, then you call it by writing
   <i>p</i>&#8593;() or <i>p</i>^(). You must include the explicit
   dereferencing operator &lsquo;&#8593;&rsquo; or &lsquo;^&rsquo;, because
   Orson thinks a pointer to a procedure is different from a procedure itself.
  </p>
  <p align="justify">
   <b>Q.</b> How do I declare an array of <i>n</i> procedures
   returning procedures returning pointers to characters?
  </p>
  <p align="justify">
   <b>A.</b> Write the equate
   [<i>n</i>]&nbsp;<b>proc</b>&nbsp;()&nbsp;<b>proc</b>&nbsp;()&nbsp;<b>ref</b>&nbsp;<i>char</i>&nbsp;<i>p</i>&nbsp;:&#8722;&nbsp;<i>e,</i>
   where <i>e</i> returns such an array. You can leave out the
   <i>e</i> if you declare <i>p</i> as a variable. Note that unlike
   the corresponding type in C, this is easily read from left to right.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I assume you want to represent characters as
   <i>char</i>&rsquo;s. I also assume that you want procedures without
   arguments, and that you want a <i>ref</i> pointer to a character. If
   you want the procedure to return a string, then you should use the type
   <i>string</i> instead of <b>ref</b>&nbsp;<i>char.</i>
  </p>
  <p align="justify">
   <b>Q.</b> What is the initial value of a variable that is not
   explicitly initialized? For example, suppose I write the equate
   <b>var</b>&nbsp;<i>int</i>&nbsp;<i>v,</i> without the
   :&#8722;&nbsp;<i>e</i> part.
  </p>
  <p align="justify">
   <b>A.</b> In Orson, the value of an uninitialized variable is
   unspecified, which means it&rsquo;s probably garbage. This is true whether
   the variable is declared in a <i>prog</i> clause or in a
   <i>with</i> clause. If you want a variable with a specific initial
   value, then you must initialize it yourself.
  </p>
  <p align="justify">
   <b>Q.</b> I used an equate like
   <i>"</i>&#8743;<i>"</i>&nbsp;:&#8722;&nbsp;<i>x</i> to
   redefine the &lsquo;&#8743;&rsquo; operator. But later, when I wrote
   <i>a</i>&nbsp;&#8743;&nbsp;<i>b,</i> Orson used the old
   definition. Why?
  </p>
  <p align="justify">
   <b>A.</b> You can redefine an operator only if it is implemented as a
   method. The operators <b>also</b>, <b>and</b>, <b>or</b>,
   <b>ref</b>, <b>row</b>, <b>type</b>, <b>var</b>,
   &lsquo;&nbsp;;&nbsp;&rsquo;, &lsquo;&#8743;&rsquo;, and
   &lsquo;&#8744;&rsquo; are not implemented as methods. They&rsquo;re built
   directly into Orson, so you can&rsquo;t redefine them. You can bind quoted
   names that resemble these operators (like <i>"</i>&#8743;<i>"</i>)
   but the operators themselves aren&rsquo;t affected. You could call
   <i>"</i>&#8743;<i>"</i>(<i>a,</i>&nbsp;<i>b</i>) if you
   want, however.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The operators <b>also, var,</b> and
   &lsquo;&nbsp;;&nbsp;&rsquo; are built in because I don&rsquo;t know why
   you&rsquo;d want to redefine them, unless you want to write programs that
   are hard to understand. Also, they&rsquo;re used a lot, and building them
   into Orson makes them more efficient than if they were defined as methods.
   The operators <b>and, or, ref, row, type,</b> &lsquo;&#8743;&rsquo;,
   and &lsquo;&#8744;&rsquo; are built in because they might not evaluate all
   their arguments, or because they evaluate them in special ways.
  </p>
  <p align="justify">
   <b>Q.</b> I used an equate like
   <i>"</i>&#8730;<i>"</i>&nbsp;:&#8722;&nbsp;<i>y</i> to define
   a square-root operator. But later, when I wrote &#8730;<i>a</i> to
   compute the square root of <i>a,</i> Orson gave me an error message.
   Why?
  </p>
  <p align="justify">
   <b>A.</b> Orson doesn&rsquo;t know that &lsquo;&#8730;&rsquo; is an
   operator. It only knows about a few operator tokens, and you can&rsquo;t add
   new ones. Binding the quoted name <i>"</i>&#8730;<i>"</i>
   doesn&rsquo;t make a new operator. You could call
   <i>"</i>&#8730;<i>"</i>(<i>a</i>) if you want, however.
  </p>
  <p align="justify">
   <b>Q.</b> Why didn&rsquo;t Orson give me error messages when I wrote
   <i>"</i>&#8743;<i>"</i>&nbsp;:&#8722;&nbsp;<i>x</i> and
   <i>"</i>&#8730;<i>"</i>&nbsp;:&#8722;&nbsp;<i>y</i> then?
  </p>
  <p align="justify">
   <b>A.</b> Quoted names can have any visible characters inside them
   (except for quotes), so <i>"</i>&#8743;<i>"</i> and
   <i>"</i>&#8730;<i>"</i> are perfectly reasonable. Why should they
   be errors? I can imagine uses for them.
  </p>
  <hr />
  <a name="forms">
  </a>
  <p>
   <b>7. Questions about forms.</b>
  </p>
  <p align="justify">
   <b>Q.</b> How are forms different from Lisp macros?
  </p>
  <p align="justify">
   <b>A.</b> By <i>Lisp,</i> I&rsquo;ll assume you mean Common Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990].
   </a>
   If you mean some other dialect, then the following may only provide partial
   answers to your question.
  </p>
  <ul>
   <li>
   <p align="justify">
    Forms use the same notation as everything else in Orson. This is not true
    of Common Lisp, in which most macros are written as expressions that return
    lists, which in turn represent other expressions. Common Lisp&rsquo;s
    <i>backquote</i> mechanism helps abbreviate macros. Orson
    doesn&rsquo;t have (and doesn&rsquo;t need) anything like backquotes.
   </p>
   <li>
   <p align="justify">
    The arguments of a form are transformed before the form is applied. This is
    not true of Common Lisp macros, whose arguments are not evaluated.
   </p>
   <li>
   <p align="justify">
    Forms are lexically scoped. This is not true of Common Lisp macros, whose
    arguments can violate lexical scoping. For example, if an argument
    <tt>x</tt> is passed to a macro that uses <tt>x</tt> as a local
    variable, then the two <tt>x</tt>&rsquo;s will be confused. Such
    <i>name capture</i> cannot occur in Orson.
   </p>
   <li>
   <p align="justify">
    Forms are typed. Specifically, form parameters have types, and the result
    returned by a form also has a type. This is not true of Common Lisp macros,
    because the language doesn&rsquo;t have types in the sense that Orson does.
   </p>
   <li>
   <p align="justify">
    Generic forms require that their arguments have types which are related to
    each other in specific ways. This is not true of Common Lisp macros, again
    because the language doesn&rsquo;t have types.
   </p>
   <li>
   <p align="justify">
    Forms can automatically inherit the behaviors of other forms that are
    defined in surrounding scopes. This is not true of Common Lisp macros.
   </p>
   <li>
   <p align="justify">
    Alternate forms can be called with varying numbers and types of arguments.
    You can do this in a Common Lisp macro, but you must write your own code to
    simulate it.
   </p>
  </ul>
  <p align="justify">
   Having said all that, Common Lisp macros work at a lower level of
   abstraction than Orson forms, and are therefore potentially more powerful.
   However, after writing lots of Orson code, I haven&rsquo;t found anything
   that I wanted to do with Orson forms, but could not. Your experience may be
   different.
  </p>
  <p align="justify">
   <b>Q.</b> How are forms different from C
   <a href="#ker1988">
    [<small>KER</small> 1988]
   </a>
   macros?
  </p>
  <p align="justify">
   <b>A.</b> Some parts of the previous answer are applicable here. Also,
   C macros work with strings of characters, or strings of tokens, but Orson
   forms work directly with the internal representations of expressions. Some
   authors call these internal representations &lsquo;&lsquo;abstract syntax
   trees.&rsquo;&rsquo; As a result, you need not include extra parentheses in
   Orson forms as you must in C macros.
  </p>
  <p align="justify">
   <b>Q.</b> My Orson program takes a very long time to compile, and/or
   makes very large binary files. I had to tell the Orson compiler to use more
   memory, too. Why is Orson so slow and inefficient?
  </p>
  <p align="justify">
   <b>A.</b> It isn&rsquo;t. You probably have large forms that are used
   repeatedly in your program. If possible, change them to procedures.
   Sometimes this requires nothing more than changing the name <b>form</b>
   to <b>proc.</b> This works because forms use the same notation as the
   rest of Orson, the subject of a previous question.
  </p>
  <p align="justify">
   <b>Q.</b> Form subsumption can&rsquo;t always detect member forms that
   can never be called. Here&rsquo;s an alternate form that returns a string
   which is the name of an integer type.
  </p>
  <blockquote>
   <p>
    <i>intkToString</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>int</i>0)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''int0''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>int</i>1)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''int1''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>int</i>2)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''int2''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>(</font>(<b>form</b>&nbsp;(<i>inj</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>i</i>((<b>f</b></font>''unknown''))
   </p>
  </blockquote>
  <p align="justify">
   Here the last member form can never be called, because an integer type
   (<i>inj</i>) is either <i>int</i>0, <i>int</i>1, or
   <i>int</i>2. However, the last member form is not subsumed.
  </p>
  <p align="justify">
   <b>A.</b> You&rsquo;re wrong, because Orson doesn&rsquo;t say how many
   integer types there are. All it says is that an implementation of Orson must
   provide <i>int</i>0, <i>int</i>1, and <i>int</i>2, at
   minimum. However, the last member form could still be called in an
   implementation of Orson that provides <i>int</i>3. You could add a
   fourth member that handles <i>int</i>3&rsquo;s, but then the last
   member could be called in an implementation that provides <i>int</i>4,
   etc.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are infinitely many integer types, but
   only finitely many are provided by any given implementation. Someday, when
   we&rsquo;re all using computers with 1024-bit words, Orson will be ready
   with the integer type <i>int</i>7 (2&#8311;&nbsp;byte
   &#215;&nbsp;2&#179;&nbsp;bit&nbsp;byte&#8315;&#185;&nbsp;= 2&#185;&#8304;
   bit&nbsp;= 1024 bit). It could happen.
  </p>
  <p align="justify">
   <b>Q.</b> But form subsumption <i>still</i> can&rsquo;t always
   detect member forms that can never be called. Here&rsquo;s an alternate form
   that returns a string which is the name of a numeric type.
  </p>
  <blockquote>
   <p>
    <i>numToString</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>form</b>&nbsp;(<i>inj</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((<b>f</b></font>''integer''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>form</b>&nbsp;(<i>rej</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((<b>f</b></font>''real''),&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>form</b>&nbsp;(<i>num</i>)&nbsp;<i>string</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((<b>f</b></font>''unknown''))
   </p>
  </blockquote>
  <p align="justify">
   The last member form can never be called, because a numeric type
   (<i>num</i>) is either an integer type (<i>inj</i>) or a real type
   (<i>rej</i>). However, the last member form is not subsumed.
  </p>
  <p align="justify">
   <b>A.</b> You&rsquo;re <i>still</i> wrong, because if jokers are
   considered to be sets of objects, then no joker is necessarily the union of
   any other jokers. The joker <i>num</i> is not necessarily the union of
   <i>inj</i> and <i>rej.</i> For example, in a prelude that provides
   complex numbers, <i>num</i> might be the union of <i>coj</i> (a
   hypothetical joker describing complex numbers), <i>inj,</i> and
   <i>rej.</i> If <i>z</i> is a complex number, then
   <i>numToString</i>(<i>z</i>) would call the last member form, and
   return ''unknown''.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jokers are defined this way so Orson can be
   extended without breaking existing programs. A program that works under the
   present Orson compiler, where the numeric jokers are <i>inj</i> and
   <i>rej,</i> should work the same way under a future Orson compiler,
   where the numeric jokers are <i>coj, inj,</i> and <i>rej.</i>
  </p>
  <p align="justify">
   <b>Q.</b> I can write a form that takes a variable number of arguments,
   by using a list. How can I write a procedure that takes a variable number of
   arguments?
  </p>
  <p align="justify">
   <b>A.</b> You can&rsquo;t. You can, however, write a form that takes
   its arguments in a list, then calls a procedure to do its work. It might
   copy its arguments into an execution object and then call the procedure on
   that object. For example, the form <i>sum</i> uses the procedure
   <i>Sum</i> to compute the sum of zero or more integers, so that the
   call <i>sum</i>(:&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4) returns 10.
  </p>
  <blockquote>
   <p>
    <i>sum</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i></font>(<b>form</b>&nbsp;(<i>list</i>&nbsp;<i>l</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>(</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>w</b></font><i>int</i>&nbsp;<i>n</i>&nbsp;:&#8722;&nbsp;<i>length</i>(<i>l</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>w</b></font><b>var</b>&nbsp;[<i>n</i>]&nbsp;<i>int</i>&nbsp;<i>a</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((</font><b>do</b>&nbsp;(<b>for</b>&nbsp;<i>inj</i>&nbsp;<i>k</i>&nbsp;<b>in</b>&nbsp;<i>n</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>do</b>&nbsp;(</font><b>do</b>&nbsp;<i>a</i>[<i>k</i>]&nbsp;:=&nbsp;<i>l</i>[<i>k</i>])&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i>((<b>do</b>&nbsp;</font><i>Sum</i>(<i>n</i>,&nbsp;<i>a</i>&#8595;)))&nbsp;
    <br />
    <font color="#FFFFFF"><i>s</i></font>
    <br />
    <i>Sum</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>n</i>,&nbsp;<b>row</b>&nbsp;<i>int</i>&nbsp;<i>a</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>(</font>(<b>with</b>&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>s</i>&nbsp;:&#8722;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>((</font><b>do</b>&nbsp;(<b>for</b>&nbsp;<i>int</i>&nbsp;<i>k</i>&nbsp;<b>in</b>&nbsp;<i>n</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>((<b>do</b>&nbsp;(</font><b>do</b>&nbsp;<i>s</i>&nbsp;+=&nbsp;<i>a</i>[<i>k</i>])&nbsp;
    <br />
    <font color="#FFFFFF"><i>S</i>((<b>do</b>&nbsp;</font><i>s</i>))
   </p>
  </blockquote>
  <p align="justify">
   For simplicity, I&rsquo;ve left out error checking on the list
   <i>l.</i> Using an array isn&rsquo;t necessarily the only way to do
   this. A technical report explains other ways, most of which are more elegant
   than this.
  </p>
  <p align="justify">
   <b>Q.</b> I&rsquo;ve redefined the form <i>"</i>+<i>"</i> so
   it can add two complex numbers, like this:
  </p>
  <blockquote>
   <p>
    <i>com</i>&nbsp;:&#8722;&nbsp;(<b>tuple</b>&nbsp;<i>real</i>&nbsp;<i>re</i>,&nbsp;<i>real</i>&nbsp;<i>im</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>
    <br />
    <i>"</i>+<i>"</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i></font>(<b>form</b>&nbsp;(<i>com</i>&nbsp;<i>l</i>,&nbsp;<i>com</i>&nbsp;<i>r</i>)&nbsp;<i>com</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>w</b></font><i>com</i>&nbsp;<i>l</i>&nbsp;:&#8722;&nbsp;(<b>past</b>&nbsp;<i>l</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>w</b></font><i>com</i>&nbsp;<i>r</i>&nbsp;:&#8722;&nbsp;(<b>past</b>&nbsp;<i>r</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>w</b></font><b>var</b>&nbsp;<i>com</i>&nbsp;<i>z</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((</font><b>do</b>&nbsp;<i>z</i>.<i>re</i>&nbsp;:=&nbsp;<i>l</i>.<i>re</i>&nbsp;+&nbsp;<i>r</i>.<i>re</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>do</b>&nbsp;</font><i>z</i>.<i>im</i>&nbsp;:=&nbsp;<i>l</i>.<i>im</i>&nbsp;+&nbsp;<i>r</i>.<i>im</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>((<b>do</b>&nbsp;</font><i>z</i>))
   </p>
  </blockquote>
  <p align="justify">
   That works fine, but if <i>z</i>&#8321; has the type
   <b>var</b>&nbsp;<i>com,</i> and <i>z</i>&#8322; has the type
   <i>com,</i> I get an error message when I write
   <i>z</i>&#8321;&nbsp;+=&nbsp;<i>z</i>&#8322;. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> Orson doesn&rsquo;t know about the relationship between
   <i>"</i>+<i>"</i> and <i>"</i>+=<i>"</i>. Redefining one
   doesn&rsquo;t redefine the other. If you want
   <i>z</i>&#8321;&nbsp;+=&nbsp;<i>z</i>&#8322; to work, you must
   redefine <i>"</i>+=<i>"</i> yourself, maybe like this.
  </p>
  <blockquote>
   <p>
    <i>"</i>+=<i>"</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i></font>(<b>form</b>&nbsp;(<b>var</b>&nbsp;<i>com</i>&nbsp;<i>l</i>,&nbsp;<i>com</i>&nbsp;<i>r</i>)&nbsp;<i>com</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>f</b></font><i>l</i>&nbsp;:=&nbsp;<i>l</i>&nbsp;+&nbsp;<i>r</i>)
   </p>
  </blockquote>
  <p align="justify">
   This works because the <i>"</i>+<i>"</i> inside the form knows how
   to do complex addition: it&rsquo;s the operator you redefined above. As long
   as they&rsquo;re redefined in the same <i>prog</i> or <i>with</i>
   clause, you can redefine the forms in any order (<i>"</i>+<i>"</i>
   before <i>"</i>+=<i>"</i> or <i>"</i>+=<i>"</i> before
   <i>"</i>+<i>"</i>) and Orson won&rsquo;t be confused.
  </p>
  <p align="justify">
   <b>Q.</b> Then why does
   <i>z</i>&#8321;&nbsp;:=&nbsp;<i>z</i>&#8322; still work? Why
   didn&rsquo;t I have to redefine <i>"</i>:=<i>"</i> so it works
   with the type <i>com</i>?
  </p>
  <p align="justify">
   <b>A.</b> The prelude defines <i>"</i>:=<i>"</i> like this,
   so it works with any object that can be the base type of a variable type
   (any <i>mut</i> object).
  </p>
  <blockquote>
   <p>
    <i>"</i>:=<i>"</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i></font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>mut</i>&nbsp;<i>lType</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>g</b></font><b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>lType</i>&nbsp;<i>rType</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>gg</b></font><b>form</b>&nbsp;(<b>var</b>&nbsp;<i>lType</i>&nbsp;<i>l</i>,&nbsp;<i>rType</i>&nbsp;<i>r</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>"</i>(<b>ggf</b></font>?<i>varSet</i>(<i>l</i>,&nbsp;<i>r</i>))
   </p>
  </blockquote>
  <p align="justify">
   The <i>gen</i> prefixes make sure the types of the variable and its new
   value are compatible. The hook ?<i>varSet</i> then does the assignment
   using magic that isn&rsquo;t available to ordinary programmers.
  </p>
  <p align="justify">
   <b>Q.</b> I want to write a form that evaluates to a variable, so I can
   call it on the left side of an assignment operator like
   <i>"</i>:=<i>".</i> However, I can&rsquo;t make it work.
  </p>
  <blockquote>
   <p>
    [256]&nbsp;<b>var</b>&nbsp;<i>int</i>&nbsp;<i>map</i>&nbsp;
    <br />
    <font color="#FFFFFF">[</font>
    <br />
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>mapped</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>int</i>&nbsp;<i>k</i>)&nbsp;<b>var</b>&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(</font>(<b>with</b>&nbsp;<i>int</i>&nbsp;<i>k</i>&nbsp;:&#8722;&nbsp;(<b>past</b>&nbsp;<i>k</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((</font><b>do</b>&nbsp;(<b>if</b>&nbsp;0&nbsp;&#8804;&nbsp;<i>k</i>&nbsp;&lt;&nbsp;<i>length</i>(<i>map</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((<b>do</b>&nbsp;(</font><b>then</b>&nbsp;<i>map</i>[<i>k</i>]&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>((<b>do</b>&nbsp;(</font><b>else</b>&nbsp;<i>throw</i>(<i>"</i>index&nbsp;out&nbsp;of&nbsp;range<i>"</i>))))
   </p>
  </blockquote>
  <p align="justify">
   The idea is that if <i>k</i> is a legal index for the array
   <i>map,</i> then the call <i>mapped</i>(<i>k</i>) should
   evaluate to the variable at that index. If <i>k</i> isn&rsquo;t a legal
   index, then the call should throw an exception. Unfortunately, Orson always
   coerces the variable to its value.
  </p>
  <p align="justify">
   <b>A.</b> The problem is that if an expression inside an <i>if</i>
   clause (or a <i>with</i> clause) evaluates to a variable, then the
   variable gets coerced to its value. The solution maybe isn&rsquo;t obvious.
  </p>
  <blockquote>
   <p>
    <i>mapped</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i></font>(<b>form</b>&nbsp;(<i>int</i>&nbsp;<i>k</i>)&nbsp;<b>var</b>&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b></font><i>map</i>[(<b>with</b>&nbsp;<i>int</i>&nbsp;<i>k</i>&nbsp;:&#8722;&nbsp;(<b>past</b>&nbsp;<i>k</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b><i>map</i>[(</font><b>do</b>&nbsp;(<b>if</b>&nbsp;0&nbsp;&#8804;&nbsp;<i>k</i>&nbsp;&lt;&nbsp;<i>length</i>(<i>map</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b><i>map</i>[(<b>do</b>&nbsp;(</font><b>then</b>&nbsp;<i>k</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>m</i>(<b>f</b><i>map</i>[(<b>do</b>&nbsp;(</font><b>else</b>&nbsp;<i>throw</i>(<i>"</i>index&nbsp;out&nbsp;of&nbsp;range<i>"</i>)))])
   </p>
  </blockquote>
  <p align="justify">
   Now <i>map</i>[...] appears directly as the form&rsquo;s body, so the
   variable to which it evaluates isn&rsquo;t coerced. Form bodies, lists, some
   method arguments, and <b>type</b> prefixes are the only places in Orson
   where variables aren&rsquo;t coerced to their values: see the
   Revised&#8315;&#185; Report for details.
  </p>
  <hr />
  <a name="parens">
  </a>
  <p>
   <b>8. Questions about parentheses.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Orson gave me all kinds of error messages when I wrote this.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font><b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i><b>p</b></font><b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i><b>p</b></font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i><b>p</b></font><b>else</b>&nbsp;<i>x</i>
   </p>
  </blockquote>
  <p align="justify">
   Why did it do that?
  </p>
  <p align="justify">
   <b>A.</b> You didn&rsquo;t put parentheses around the <i>proc</i>
   clause, or around the <i>if</i> clause. You should have written this.
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font>(<b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>((</font><b>else</b>&nbsp;<i>x</i>))
   </p>
  </blockquote>
  <p align="justify">
   Parentheses are required parts of clauses. As a result, you don&rsquo;t need
   silly things like &lsquo;<tt>{</tt>&rsquo; and
   &lsquo;<tt>}</tt>&rsquo;, or like <b>begin</b> and
   <b>end.</b>
  </p>
  <p align="justify">
   <b>Q.</b> It&rsquo;s hard to keep all those parentheses balanced, so I
   started writing them like they&rsquo;re curly brackets in C
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
  </p>
  <blockquote>
   <p>
    <i>abs</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>(&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(</font><b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>x</i>)&nbsp;<i>int</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b></font>(&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b>(</font><b>if</b>&nbsp;<i>x</i>&nbsp;&lt;&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b>(</font><b>then</b>&nbsp;&#8722;&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b>(</font><b>else</b>&nbsp;<i>x</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i>(<b>p</b></font>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>a</i></font>)
   </p>
  </blockquote>
  <p align="justify">
   What do you think?
  </p>
  <p align="justify">
   <b>A.</b> I think it&rsquo;s ugly, because it uses too much whitespace.
   It also seems silly, since many text editors will help you balance
   parentheses. If you like it, though, go ahead and use it.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As far as I&rsquo;m concerned, you can format
   and indent programs however you like, as long as you do so consistently.
   However, you may have to change your style if you write code that other
   people (colleagues or teachers) need to look at. This is true even in a
   language like Orson that&rsquo;s intended for programmers who work alone.
  </p>
  <p align="justify">
   <b>Q.</b> Orson uses too many parentheses. It&rsquo;s as bad as Lisp!
  </p>
  <p align="justify">
   <b>A.</b> Dialects of Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990]
   </a>
   are my favorite programming languages. If we all wrote in Lisp, then many of
   our programming problems would go away. But that&rsquo;s not what you meant.
   For the sake of argument, let&rsquo;s assume parentheses are evil, so
   programs should use as few of them as possible. I claim that for some
   programs, Orson uses <i>fewer</i> parentheses than other languages.
   Consider the following C fragment:
  </p>
  <blockquote>
   <p>
    <tt>if&nbsp;(a&nbsp;&lt;&nbsp;b)&nbsp;</tt>
    <br />
    <tt>{&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;count&nbsp;-=&nbsp;1;&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;return&nbsp;-1;&nbsp;</tt>
    <br />
    <tt>}&nbsp;</tt>
    <br />
    <tt>else&nbsp;if&nbsp;(a&nbsp;&gt;&nbsp;b)&nbsp;</tt>
    <br />
    <tt>{&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;count&nbsp;+=&nbsp;1;&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;return&nbsp;1;&nbsp;</tt>
    <br />
    <tt>}&nbsp;</tt>
    <br />
    <tt>else&nbsp;</tt>
    <br />
    <tt>{&nbsp;</tt>
    <br />
    <tt>&nbsp;&nbsp;return&nbsp;0;&nbsp;</tt>
    <br />
    <tt>}</tt>
   </p>
  </blockquote>
  <p align="justify">
   It uses ten parentheses, if you count braces. An equivalent Orson fragment
   looks like this.
  </p>
  <blockquote>
   <p>
    (<b>if</b>&nbsp;<i>a</i>&nbsp;&lt;&nbsp;<i>b</i>&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>then</b>&nbsp;<i>count</i>&nbsp;&#8722;=&nbsp;1&nbsp;
    <br />
    <font color="#FFFFFF">(<b>then</b>&nbsp;</font>&#8722;1&nbsp;
    <br />
    <font color="#FFFFFF">(</font><b>else</b>&nbsp;<b>if</b>&nbsp;<i>a</i>&nbsp;&gt;&nbsp;<i>b</i>&nbsp;
    <br />
    <font color="#FFFFFF">(<b>else</b>&nbsp;</font><b>then</b>&nbsp;<i>count</i>&nbsp;+=&nbsp;1&nbsp;
    <br />
    <font color="#FFFFFF">(<b>else</b>&nbsp;<b>then</b>&nbsp;</font>1&nbsp;
    <br />
    <font color="#FFFFFF">(<b>else</b>&nbsp;</font><b>else</b>&nbsp;0)
   </p>
  </blockquote>
  <p align="justify">
   The Orson fragment uses <i>two</i> parentheses, and it doesn&rsquo;t
   need semicolons or <i>return</i> statements either. Of course this is
   only a small fragment of a program, and the results will depend on your
   brace style. For example, you don&rsquo;t really need braces around the last
   C <i>return</i> statement.
  </p>
  <p align="justify">
   <b>Q.</b> If you like Lisp so much, then why doesn&rsquo;t Orson look
   like Lisp?
  </p>
  <p align="justify">
   <b>A.</b> One of Lisp&rsquo;s many advantages is that its programs are
   expressed using a simple prefix notation, so programmers need not remember
   the details of a complex syntax. The syntax also makes it easy to extend the
   language by using macros.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unfortunately, Lisp has scared most
   programmers away, maybe because it reminds them of mathematics (it has that
   spooky Greek letter &#955;). Even the functional programming community has
   switched to languages with a familiar appearance, such as Haskell
   <a href="#hud1992">
    [<small>HUD</small> 1992].
   </a>
   It saddens me to say this, and I hope I&rsquo;m wrong, but Lisp is dying. We
   should try to steal what we can from its corpse before they bury it.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson&rsquo;s syntax is intended as a
   compromise between the simplicity of Lisp and the familiarity of other
   languages. Orson&rsquo;s <small>BNF</small> fits on about four pages
   <a href="#moe2017">
    [<small>MOE</small> 2017].
   </a>
   I might have squeezed it into three if I hadn&rsquo;t restricted myself to
   classical 1960 <small>BNF</small>
   <a href="#nau1963">
    [<small>NAU</small> 1963].
   </a>
   The current Orson-to-<small>GCC</small> translator resembles a Lisp
   interpreter internally, and Orson forms are really just typed
   &#955;-expressions
   <a href="#bar1984">
    [<small>BAR</small> 1984].
   </a>
   However, you can write Orson programs without knowing that.
  </p>
  <hr />
  <a name="pointers">
  </a>
  <p>
   <b>9. Questions about pointers.</b>
  </p>
  <p align="justify">
   <b>Q.</b> I&rsquo;m deliberately trying to dereference <i>nil</i>
   to cause an error during execution, so I can get the attention of a
   debugger. However, I can&rsquo;t figure out how to do it! If I write
   <i>nil</i>&#8593; or
   <i>nil</i>{<b>ref</b>&nbsp;<i>void</i>}&#8593;, Orson gives
   me an error message. How does Orson know what I&rsquo;m trying to do, and
   how can I fool it?
  </p>
  <p align="justify">
   <b>A.</b> Orson tests during transformation if (1) you&rsquo;re trying
   to dereference <i>nil,</i> (2) you&rsquo;re trying to dereference any
   pointer whose type is <i>null,</i> and (3) you&rsquo;re trying to cast
   a pointer other than <i>nil</i> to <i>null.</i> The way to avoid
   the tests is to use a pointer variable, since Orson can&rsquo;t test the
   values of variables during transformation.
  </p>
  <blockquote>
   <p>
    <b>var</b>&nbsp;<b>ref</b>&nbsp;<i>void</i>&nbsp;<i>p</i>&nbsp;:&#8722;&nbsp;<i>nil</i>&nbsp;
    <br />
    <i>bang</i>&nbsp;:&#8722;&nbsp;(<b>form</b>&nbsp;()&nbsp;<i>void</i>:&nbsp;<i>p</i>&#8593;)
   </p>
  </blockquote>
  <p align="justify">
   You can now call <i>bang</i>() to cause an execution error.
  </p>
  <hr />
  <a name="string">
  </a>
  <p>
   <b>10. Questions about strings.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Orson represents a string as a pointer to an array of bytes,
   terminated by a zero-byte. This is a poor representation, because you
   can&rsquo;t compute a string&rsquo;s length without traversing it. Why does
   Orson represent strings that way?
  </p>
  <p align="justify">
   <b>A.</b> Strings are the favorite data structure of bad programmers.
   They want to represent most objects as strings. They would be better off
   with data structures that are specifically designed for the objects they
   want to represent. In general, you should use strings only for things that
   are connected somehow with input and output.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This means the representation used for
   strings is largely irrelevant, and the designer of a programming language is
   free to pick any representation that is convenient. I designed Orson to use
   the same representation as C
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
   It&rsquo;s convenient because it lets Orson use library procedures that have
   already been written for C, without change.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you print a string, then you must traverse
   it to visit its characters. You might need to compute the number of columns
   needed by the string before you print it. However, if the string contains
   Unicode characters
   <a href="#uni2006">
    [<small>UNI</small> 2006],
   </a>
   then you must traverse the string anyway to compute this, since Unicode
   characters have varying widths. Traversing the string shouldn&rsquo;t affect
   run time much, because it should be much faster than printing.
  </p>
  <hr />
  <a name="tokens">
  </a>
  <p>
   <b>11. Questions about tokens.</b>
  </p>
  <p align="justify">
   <b>Q.</b> I get an error whenever I use a dash. For example, I get an
   error when I write <i>j</i>&nbsp;:&#8212;&nbsp;1, and I get another
   error when I write <i>j</i>&nbsp;&#8211;&nbsp;1. What am I doing wrong?
  </p>
  <p align="justify">
   <b>A.</b> Maybe you&rsquo;re using the wrong kind of dash. Orson
   programs can be written in Unicode
   <a href="#uni2006">
    [<small>UNI</small> 2006],
   </a>
   which has many characters that look like dashes. For example:
  </p>
  <blockquote>
   <table cellpadding="0" cellspacing="0">
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;-&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+002D)&nbsp;
      </p>
     </td>
     <td>
      <p>
       is a <small>HYPHEN</small>-<small>MINUS</small>,
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8208;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2010)
      </p>
     </td>
     <td>
      <p>
       is a <small>HYPHEN</small>,
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8209;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2011)
      </p>
     </td>
     <td>
      <p>
       is a <small>NON</small>-<small>BREAKING HYPHEN</small>,
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8210;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2012)
      </p>
     </td>
     <td>
      <p>
       is a <small>FIGURE DASH</small>,
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8211;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2013)
      </p>
     </td>
     <td>
      <p>
       is an <small>EN DASH</small>,
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8212;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2014)
      </p>
     </td>
     <td>
      <p>
       is an <small>EM DASH</small>,
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8213;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2015)
      </p>
     </td>
     <td>
      <p>
       is a <small>HORIZONTAL BAR</small>, and
      </p>
     </td>
    </tr>
    <tr valign="top">
     <td>
      <p>
       &lsquo;&nbsp;&#8722;&nbsp;&rsquo;&nbsp;
      </p>
     </td>
     <td>
      <p>
       (U+2212)
      </p>
     </td>
     <td>
      <p>
       is a <small>MINUS SIGN</small>.
      </p>
     </td>
    </tr>
   </table>
  </blockquote>
  <p align="justify">
   This may not be a complete list. Some of them may even look the same,
   depending on your browser&rsquo;s default font, but they are different
   characters, with different codes. Sheesh!
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Orson recognizes only two of these:
   &lsquo;&nbsp;-&nbsp;&rsquo;, a
   <small>HYPHEN</small>-<small>MINUS</small> (U+002D), which is the
   familiar <small>ASCII</small>
   <a href="#ans1986">
    [<small>ANS</small> 1986]
   </a>
   character that you get from <small>US</small> keyboards, and
   &lsquo;&nbsp;&#8722;&nbsp;&rsquo;, a <small>MINUS SIGN</small>
   (U+2212), that you get from a character palette. You can write sums and
   terms using either character. You can also write a colon-dash in an equate
   using either character.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Technically, the
   <small>HYPHEN</small>-<small>MINUS</small> character is preferred
   in English text, and the <small>MINUS SIGN</small> character is
   preferred in Orson code. The Orson library uses this convention. However,
   you don&rsquo;t need to care unless you&rsquo;re modifying the definition of
   the subtraction operator in the Standard Prelude, or unless you&rsquo;re
   anal-retentively fussy about how your programs look, like I am.
  </p>
  <p align="justify">
   <b>Q.</b> You use &lsquo;&lt;&gt;&rsquo; as the operator that tests for
   inequality. By analogy with &lsquo;&lt;=&rsquo; and &lsquo;&gt;=&rsquo;,
   this suggests <i>less than or greater than.</i> However, some objects,
   like complex numbers, can be unequal without being less or greater. You
   should use something else.
  </p>
  <p align="justify">
   <b>A.</b> I agree, but all the good choices in
   <small>ASCII</small> are taken. I can&rsquo;t use &lsquo;/=&rsquo;,
   &lsquo;|=&rsquo;, or &lsquo;~=&rsquo; because they&rsquo;re assignment
   operators. I can&rsquo;t use &lsquo;!=&rsquo; because an exclamation mark
   denotes a comment. I can&rsquo;t use &lsquo;#&rsquo; because it denotes an
   integer constant. I don&rsquo;t want to use &lsquo;\=&rsquo; because
   it&rsquo;s too easily confused with &lsquo;/=&rsquo;. Things like
   &lsquo;=/=&rsquo; and &lsquo;=/&rsquo; are ugly. A reserved name like
   <b>neq</b> is even uglier: it looks like Klingon
   <a href="#okr1992">
    [<small>OKR</small> 1992].
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If you use Orson on a system that supports
   Unicode (and most systems do) then you can write &lsquo;&#8800;&rsquo; as a
   synonym for &lsquo;&lt;&gt;&rsquo;. If you don&rsquo;t, then you can still
   write <b>not</b>&nbsp;(<i>a</i>&nbsp;=&nbsp;<i>b</i>).
  </p>
  <p align="justify">
   <b>Q.</b> If &lsquo;&lt;&gt;&rsquo; and &lsquo;&#8800;&rsquo; test for
   inequality, then what about this?
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>nonzero</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>n</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>if</b>&nbsp;<i>n</i>&nbsp;!=&nbsp;0&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((</font><b>then</b>&nbsp;<i>writeln</i>(''Not&nbsp;zero.'')))
   </p>
  </blockquote>
  <p align="justify">
   It works correctly. Why?
  </p>
  <p align="justify">
   <b>A.</b> Well, it <i>compiles</i> correctly; whether it
   <i>works</i> correctly is a different question. The exclamation point
   starts a comment, which includes the rest of the line. So you&rsquo;ve
   really written a procedure like this.
  </p>
  <blockquote>
   <p>
    <i>nonzero</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>n</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>(</font>(<b>if</b>&nbsp;<i>n</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>n</i>((</font><b>then</b>&nbsp;<i>writeln</i>(''Not&nbsp;zero.'')))
   </p>
  </blockquote>
  <p align="justify">
   It <i>seems</i> to work correctly because the <i>if</i> clause
   tests if the expression that comes after <b>if</b> is not zero. If so,
   then it evaluates the expression that comes after <b>then.</b> You got
   lucky, but you wouldn&rsquo;t have if you&rsquo;d written this.
  </p>
  <blockquote>
   <p>
    !&nbsp;&nbsp;W<small>RONG</small>.&nbsp;
    <br />
    <i>unequal</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>u</i></font>(<b>proc</b>&nbsp;(<i>int</i>&nbsp;<i>a</i>,&nbsp;<i>int</i>&nbsp;<i>b</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>u</i>(</font>(<b>if</b>&nbsp;<i>a</i>&nbsp;!=&nbsp;<i>b</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>u</i>((</font><b>then</b>&nbsp;<i>writeln</i>(''Not&nbsp;equal.'')))
   </p>
  </blockquote>
  <p align="justify">
   Something like this happened to me when I got C
   <a href="#ker1988">
    [<small>KER</small> 1988]
   </a>
   and Orson confused. I therefore considered changing the definition of
   comments so that the exclamation point must be followed by a blank. However,
   I realized that this wouldn&rsquo;t stop similarly confused people from
   using the exclamation mark as the <small>NOT</small> operator, so I
   never made the change.
  </p>
  <p align="justify">
   <b>Q.</b> There&rsquo;s something wrong with string literals. When I
   write <i>"</i>Hello,&nbsp;world!<i>"</i> with quotation marks, I
   get an error message about an undeclared name.
  </p>
  <p align="justify">
   <b>A.</b> That&rsquo;s because
   <i>"</i>Hello,&nbsp;world!<i>"</i> isn&rsquo;t a string literal.
   It&rsquo;s a quoted name. You get an error because the name isn&rsquo;t
   declared. Write ''Hello,&nbsp;world!'' instead. That&rsquo;s
   <i>apostrophe, apostrophe, hello, comma, blank, world, exclamation point,
   apostrophe, apostrophe.</i>
  </p>
  <p align="justify">
   <b>Q.</b> There&rsquo;s something wrong with character literals. When I
   write <i>"</i>x<i>"</i> with quotation marks I get an error
   message about an undeclared name.
  </p>
  <p align="justify">
   <b>A.</b> That&rsquo;s because <i>"</i>x<i>"</i> isn&rsquo;t
   a character literal. It&rsquo;s a quoted name. You get an error because the
   name isn&rsquo;t declared. Write 'x' instead. That&rsquo;s
   <i>apostrophe, x, apostrophe.</i>
  </p>
  <p align="justify">
   <b>Q.</b> Why does Orson use such a goofy notation for character
   literals and string literals?
  </p>
  <p align="justify">
   <b>A.</b> Orson needs to have quoted names for operators like
   <i>"</i>+<i>"</i> and <i>"</i>:=<i>".</i> I think quoted
   names should be delimited by single characters, and given the limitations of
   the <small>ASCII</small> character set, the best choice is the
   quotation mark &lsquo;&nbsp;<i>"</i>&nbsp;&rsquo;. Orson must be
   compatible with <small>ASCII</small>, so its programs can be typed on
   ordinary <small>US</small> keyboards, and so they can run on old
   computers that don&rsquo;t support Unicode.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Once I&rsquo;d used the quotation mark, I had
   to use other characters to notate character and string literals. I also had
   to notate character and string literals in different ways, so Orson can tell
   them apart. For example, Pascal
   <a href="#jen1974">
    [<small>JEN</small> 1974]
   </a>
   used a single quote &lsquo;&nbsp;'&nbsp;&rsquo; to notate both
   characters and strings, so that 'x' was a character literal. It had
   <i>no way</i> to notate a string literal with exactly one character!
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Given these constraints, I decided to notate
   characters with single apostrophes, like 'x', because it&rsquo;s what C
   uses. Since strings are like characters but
   &lsquo;&lsquo;bigger,&rsquo;&rsquo; I decided to notate them with two
   apostrophes, like ''Hello,&nbsp;world!''. If Orson had objects bigger
   than strings, but still like strings, then maybe I&rsquo;d notate them using
   <i>three</i> apostrophes.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; By the way, Orson&rsquo;s notation for
   strings makes it easy to write
   ''Type&nbsp;<i>"</i>quit<i>"</i>&nbsp;to&nbsp;exit'' and
   ''Type&nbsp;'exit'&nbsp;to&nbsp;quit'' without escape characters such
   as backslashes. I hope these examples are easy to read on your browser.
  </p>
  <p align="justify">
   <b>Q.</b> How can I write the name of a constant in upper case letters,
   like in C and Java
   <a href="#gos1996">
    [<small>GOS</small> 1996]?
   </a>
   A name that starts with an upper case letter is a secret name, so I
   can&rsquo;t use it outside the <i>prog</i> clause where it&rsquo;s
   defined.
  </p>
  <p align="justify">
   <b>A.</b> There&rsquo;s no way to do that. This is deliberate. Writing
   constant names in upper case is a bad idea, even in C-like languages,
   despite what style guides, teachers, and textbooks say. Here&rsquo;s why.
  </p>
  <ul>
   <li>
   <p align="justify">
    Someday you might want to turn the constant into a variable. For example,
    you might decide that its value should be a run-time option. Then you must
    change the name wherever it appears.
   </p>
   <li>
   <p align="justify">
    In Orson, a name&rsquo;s type tells you if it&rsquo;s a constant or a
    variable, not the way it&rsquo;s spelled. You shouldn&rsquo;t encode an
    object&rsquo;s type into its name, as in the &lsquo;&lsquo;Hungarian
    Style,&rsquo;&rsquo; because then you must change its name if you ever
    change its type.
   </p>
   <li>
   <p align="justify">
    Orson constant names are different from C constant names, so you
    shouldn&rsquo;t write them as you do in C.
   </p>
   <li>
   <p align="justify">
    Orson uses constant names more often than C. It&rsquo;s a hassle to spell
    them in a special way.
   </p>
   <li>
   <p align="justify">
    It&rsquo;s ugly. It looks like you&rsquo;re SHOUTING at the person reading
    your code. I don&rsquo;t like to be shouted at, and probably you
    don&rsquo;t either.
   </p>
  </ul>
  <p align="justify">
   If you really must use capital letters for some reason, then you can write a
   quoted name, as in <i>"</i>CONSTANT<i>",</i> but that&rsquo;s ugly
   too. If you&rsquo;d rather use C, then why are you using Orson?
  </p>
  <p align="justify">
   <b>Q.</b> But then why are secret names spelled differently from other
   names? If you want to change a secret name into a plain name, then you must
   also change it whenever it appears.
  </p>
  <p align="justify">
   <b>A.</b> Yes, secret names are inconsistent with what I just said.
   However, having secret names spelled with initial upper case letters was
   very easy to implement. It also lets secret names be parts of tuple types
   and symbol types.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It&rsquo;s also simpler than declaring names
   with a special type prefix, like <b>sec</b>, so that
   <b>sec</b>&nbsp;<b>var</b>&nbsp;<i>t</i>&nbsp;<i>v</i>
   would declare <i>v</i> to be a secret variable name. If Orson had a
   <b>sec</b> prefix, then it would raise lots of questions that I
   don&rsquo;t know how to answer. For example, is
   <b>sec</b>&nbsp;<b>var</b>&nbsp;<i>t</i> different from
   <b>var</b>&nbsp;<b>sec</b>&nbsp;<i>t,</i> and if so, how? Is
   <b>sec</b>&nbsp;<b>sec</b>&nbsp;<i>t</i> different from
   <b>sec</b>&nbsp;<i>t,</i> and if so, how? What does it mean to use
   <b>sec</b>&nbsp;<i>t</i> as a parameter type in a method, or as a
   yield type in a method? Orson&rsquo;s type system is complex enough already.
  </p>
  <p align="justify">
   <b>Q.</b> How can I make a name that&rsquo;s both a quoted name and a
   secret name?
  </p>
  <p align="justify">
   <b>A.</b> There ought to be a way to do this, but there isn&rsquo;t.
   Sorry. A secret name starts with an upper case Roman letter. A quoted name
   starts with a quote &lsquo;&nbsp;<i>"</i>&nbsp;&rsquo;.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I suppose Orson could be changed so a quoted
   name is secret if the first character after the double quote is an upper
   case Roman letter. That way a name like <i>"</i>Secret<i>"</i>
   would be a secret quoted name. However, that doesn&rsquo;t solve the
   problem, since there would still be no way to make something like
   <i>"</i>+<i>"</i> be a secret name.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; An early version of Orson used backslashes to
   notate secret names, so \<i>secret</i> was a secret plain name, and
   \<i>"</i>secret<i>"</i> was a secret quoted name. This was hard to
   read and write, especially for programs with many secret names, so I changed
   it.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I use quoted names only for operators (like
   <i>"</i>+<i>"</i>) and for constants in enumerations (like
   <i>"</i>unexpected&nbsp;value<i>"</i>). I haven&rsquo;t found a
   situation yet where these should be secret.
  </p>
  <p align="justify">
   <b>Q.</b> If names that start with capital letters are secret names,
   then how can I write a proper name that&rsquo;s not a secret name?
  </p>
  <p align="justify">
   <b>A.</b> You could use lower case letters, as in
   <i>johnSmith,</i> or you could use a quoted name, as in
   <i>"</i>John&#9251;Smith<i>".</i> Maybe you could write
   <i>mrJohnSmith</i> if Smith thinks he&rsquo;s being insulted otherwise.
   However, maybe he&rsquo;d also be insulted if he knew you&rsquo;re
   representing him as a data structure that has so little state information.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This reminds me of the (apocryphal?) story
   about why early computer printers used only upper case letters, even though
   everyone knew that lower case letters are easier to read. The reason is that
   you can&rsquo;t spell <i>God</i> correctly with lower case letters. I
   don&rsquo;t have a good answer for that, except to say that it seems
   presumptuous to write a program with <i>God</i> in it. John
   Updike&rsquo;s novel <i>Roger&rsquo;s Version</i>
   <a href="#upd1986">
    [<small>UPD</small> 1986]
   </a>
   discusses such a program in detail. It even includes Lisp code.
  </p>
  <hr />
  <a name="types">
  </a>
  <p>
   <b>12. Questions about types.</b>
  </p>
  <p align="justify">
   <b>Q.</b> In Orson, types have types. Doesn&rsquo;t that lead to
   contradictions or paradoxes?
  </p>
  <p align="justify">
   <b>A.</b> There are paradoxes in set theory that result from having
   sets of sets. Perhaps the best known is <i>Russell&rsquo;s paradox</i>
   <a href="#ruc1982">
    [<small>RUC</small> 1982],
   </a>
   where the members of a set <i>S</i> are said to be all sets that are
   not members of themselves. Is <i>S</i> a member of itself? If it is,
   then it isn&rsquo;t. If it isn&rsquo;t, then it is.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mathematically, Orson types are sets of
   objects, and Orson types can have types. It&rsquo;s therefore tempting to
   suppose you could state Russell&rsquo;s paradox in Orson&rsquo;s type
   system. I don&rsquo;t think this is possible, because (among other things)
   it isn&rsquo;t strong enough to express <small>NOT</small>. You
   can&rsquo;t make a type <i>S</i> that describes all objects which are
   not of the type <i>S.</i> At least I <i>think</i> you can&rsquo;t.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I&rsquo;d be happy to hear from anyone who
   can prove that Orson&rsquo;s type system leads to a paradox, but I probably
   won&rsquo;t understand your proof. I also won&rsquo;t change Orson&rsquo;s
   type system to eliminate the paradox, unless it&rsquo;s easy to make the
   change, or unless your proof breaks something important.
  </p>
  <p align="justify">
   <b>Q.</b> Can a tuple contain a pointer to itself?
  </p>
  <p align="justify">
   <b>A.</b> Yes. There are at least two ways to write the type of such a
   tuple. For example, both of the following code fragments bind
   <i>node</i> to the type of a node in a linear chain of tuples. I call
   them <i>chains</i> because Orson provides objects called
   <i>lists</i> that are different from these.
  </p>
  <blockquote>
   <table cellpadding="0" cellspacing="0">
    <tr valign="top">
     <td>
      <p>
       <i>link</i>&nbsp;:&#8722;&nbsp;<b>ref</b>&nbsp;<i>node</i>&nbsp;
       <br />
       <i>node</i>&nbsp;:&#8722;&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i></font>(<b>tuple</b>&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><i>string</i>&nbsp;<i>name</i>,&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><b>var</b>&nbsp;<i>link</i>&nbsp;<i>next</i>)
      </p>
     </td>
     <td>
      <p>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      </p>
     </td>
     <td>
      <p>
       &nbsp;
       <br />
       <i>node</i>&nbsp;:&#8722;&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i></font>(<b>tuple</b>&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><i>string</i>&nbsp;<i>name</i>,&nbsp;
       <br />
       <font color="#FFFFFF"><i>n</i>(<b>t</b></font><b>var</b>&nbsp;<b>ref</b>&nbsp;<i>node</i>&nbsp;<i>next</i>)
      </p>
     </td>
    </tr>
   </table>
  </blockquote>
  <p align="justify">
   You can even have a form that returns the type of such a chain. For example,
   the form <i>chain</i> returns the type of a node in a linear chain of
   tuples. Each tuple contains an object whose type is <i>base.</i>
  </p>
  <blockquote>
   <p>
    <i>chain</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i></font>(<b>form</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>base</i>)&nbsp;<b>type</b>&nbsp;<i>tup</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>(</font>(<b>with</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b></font><i>node</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b><i>n</i></font>(<b>tuple</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b><i>n</i>(<b>t</b></font><i>base</i>&nbsp;<i>name</i>,&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((<b>w</b><i>n</i>(<b>t</b></font><b>var</b>&nbsp;<b>ref</b>&nbsp;<i>node</i>&nbsp;<i>next</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>c</i>((</font><b>do</b>&nbsp;<i>node</i>))
   </p>
  </blockquote>
  <p align="justify">
   As a result, <i>chain</i>(<b>var</b>&nbsp;<i>int</i>) returns
   the type of a node in a linear chain of tuples, each of which contains an
   integer variable.
  </p>
  <p align="justify">
   <b>Q.</b> The equate
   [10]&nbsp;<i>char</i>&nbsp;<i>tc</i>&nbsp;:&#8722;&nbsp;''ten&nbsp;chars''
   gives me an error. What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> You&rsquo;re correct that the string ''ten&nbsp;chars''
   has ten characters, because there&rsquo;s an extra <i>null</i>
   character &rsquo;\0&rsquo; at the end, as in C
   <a href="#ker1988">
    [<small>KER</small> 1988].
   </a>
   The problem is that ''ten&nbsp;chars'' has the type <i>string,</i>
   which is bound to <b>row</b>&nbsp;<i>char</i>0. The equate expects
   an array of type [10]&nbsp;<i>char,</i> a different type. Also, your
   array type describes an array of ten <i>char</i>1&rsquo;s (each 32
   bits) but but there are ten <i>char</i>0&rsquo;s in your string (each 8
   bits). There are two different kinds of characters because Orson uses the
   <small>UTF</small>-8 encoding for strings
   <a href="#uni2006">
    [<small>UNI</small> 2006].
   </a>
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You might rewrite the equate as
   <i>string</i>&nbsp;<i>tc</i>&nbsp;:&#8722;&nbsp;''ten&nbsp;chars''.
   It doesn&rsquo;t give you the array that you wanted, but a string. That
   might be just as good, since you can index it to obtain individual
   characters. For example, <i>tc</i>[0] returns the character 't'.
   This works because each character in the string is represented as a single
   byte.
  </p>
  <p align="justify">
   <b>Q.</b> Why can&rsquo;t I pass <i>nil</i> to a generic form? I
   wrote something like this:
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>b</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>g</b></font><b>form</b>&nbsp;(<b>row</b>&nbsp;<i>b</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b></font>...)
   </p>
  </blockquote>
  <p align="justify">
   When I call <i>foo</i>(<i>nil</i>), I get an error. My form
   expects a <i>row</i> pointer as an argument, and I thought
   <i>nil</i>&rsquo;s type was a subtype of any <i>row</i> pointer
   type.
  </p>
  <p align="justify">
   <b>A.</b> The type of <i>nil</i> is <i>null,</i> which is
   indeed a subtype of any pointer type, including any <i>row</i> pointer
   type. However, since you wrote a generic form that binds <i>b,</i>
   Orson thinks you want to do something with the base type of the pointer
   <i>p.</i> The problem is that <i>null</i> doesn&rsquo;t have a
   base type, so your form can&rsquo;t accept <i>nil</i> as an argument.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are several things you might do. One is
   to write an alternate form with two members: one to handle <i>null</i>
   pointers and another to handle everything else. Maybe the one that handles
   <i>null</i> pointers should report an error.
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>form</b>&nbsp;(<i>null</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>f</b></font>...),&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>b</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>g</b></font><b>form</b>&nbsp;(<b>row</b>&nbsp;<i>b</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>gf</b></font>...))
   </p>
  </blockquote>
  <p align="justify">
   Another is to put the <b>row</b> prefix in a different place, and then
   use an <i>if</i> clause inside the form to test if you have
   <i>nil</i> or not. You must now call <i>base</i> explicitly to get
   <i>p</i>&rsquo;s base type. I tested if <i>pType</i> was
   <i>null,</i> instead of testing if <i>p</i> equals
   <i>nil,</i> so the test is done during transformation.
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<b>row</b>&nbsp;<i>exe</i>&nbsp;<i>pType</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>g</b></font><b>form</b>&nbsp;(<i>pType</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b></font>(<b>if</b>&nbsp;<i>pType</i>&nbsp;&#8838;&nbsp;<i>null</i>&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b>(</font><b>then</b>&nbsp;...&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(<b>gf</b>(</font><b>else</b>&nbsp;...))
   </p>
  </blockquote>
  <p align="justify">
   Still another is to keep the original definition of <i>foo,</i> but
   cast <i>nil</i> to another pointer type before you pass it. For
   example, you could write
   <i>foo</i>(<i>nil</i>{<b>row</b>&nbsp;<i>void</i>}). You
   can even arrange for Orson to do this automatically, like so:
  </p>
  <blockquote>
   <p>
    <i>foo</i>&nbsp;:&#8722;&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i></font>(<b>alt</b>&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>form</b>&nbsp;(<i>null</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>f</b></font><i>foo</i>(<i>nil</i>{<b>row</b>&nbsp;<i>void</i>})),&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>(</font>(<b>gen</b>&nbsp;(<b>type</b>&nbsp;<i>exe</i>&nbsp;<i>b</i>)&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>g</b></font><b>form</b>&nbsp;(<b>row</b>&nbsp;<i>b</i>&nbsp;<i>p</i>)&nbsp;<i>void</i>:&nbsp;
    <br />
    <font color="#FFFFFF"><i>f</i>((<b>gf</b></font>...))
   </p>
  </blockquote>
  <p align="justify">
   All of these are just kludges to get around <i>null</i>&rsquo;s lack of
   a base type.
  </p>
  <p align="justify">
   <b>Q.</b> So why doesn&rsquo;t <i>null</i> have a base type? Why
   couldn&rsquo;t its base type be <i>void</i>?
  </p>
  <p align="justify">
   <b>A.</b> The pointer <i>nil</i> references no object, so its type
   <i>null</i> can&rsquo;t have a base type. It&rsquo;s not obvious what
   type the lack of an object should have: what type is a unicorn? The base
   type of <i>null</i> can&rsquo;t be <i>void</i> because
   <i>void</i> is the type of an object, namely <i>skip.</i> If
   <i>null</i> had the base type <i>void,</i> then maybe
   <i>nil</i> would reference <i>skip,</i> and you could dereference
   it. That shouldn&rsquo;t be possible.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When designing a programming language,
   it&rsquo;s tempting to pick some object with hardly a meaning, like
   <i>void,</i> and then use it everywhere to plug semantic holes. Common
   Lisp
   <a href="#ste1990">
    [<small>STE</small> 1990]
   </a>
   uses its <tt>nil</tt> object that way, and C uses its
   <tt>void</tt> type that way too. I tried not to do things like that in
   Orson.
  </p>
  <hr />
  <a name="current">
  </a>
  <p>
   <b>13. Questions about the current implementation of Orson.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Your Orson compiler doesn&rsquo;t follow the
   &lsquo;&lsquo;Endian Pill C Coding Standard,&rsquo;&rsquo; which says that
   only the first four characters of names are significant. Because of this, I
   can&rsquo;t run Orson on my <small>IBM</small> 650. (Insert your
   favorite C
   <a href="#ker1988">
    [<small>KER</small> 1988]
   </a>
   coding standard and your favorite retro computer.)
  </p>
  <p align="justify">
   <b>A.</b> It&rsquo;s worse than you think. The Orson compiler has
   non-portable C code in it. It assumes pointers are totally ordered, even if
   they don&rsquo;t point into the same array. It uses lots of
   G<small>NU</small> extensions, and it translates Orson to C code that
   also uses lots of G<small>NU</small> extensions
   <a href="#sta2008">
    [<small>STA</small> 2008].
   </a>
   Despite that, it seems to work on every computer I&rsquo;ve tried, except on
   those without executable stacks (there&rsquo;s a question about that later).
   I&rsquo;m sorry it doesn&rsquo;t work on your 1956 computer.
  </p>
  <p align="justify">
   <b>Q.</b> Is there a version of Orson that works under Windows? (Insert
   your favorite for-profit operating system.)
  </p>
  <p align="justify">
   <b>A.</b> At present, Orson runs only on Unix-like operating systems,
   such as G<small>NU</small>/Linux
   <a href="#stv2005">
    [<small>STV</small> 2005].
   </a>
   An old, incomplete version of Orson ran successfully under Sun&rsquo;s
   Solaris, many years ago. I don&rsquo;t know how hard it would be to make
   Orson work under another system.
  </p>
  <p align="justify">
   <b>Q.</b> Can your compiler translate Orson to dialects of C other than
   just G<small>NU</small> C? Can it translate to <small>ANSI</small>
   C? (Insert your favorite C dialect.)
  </p>
  <p align="justify">
   <b>A.</b> No. I have no plans to make Orson produce
   <small>ANSI</small> C code. Sorry. Implementing the compiler as a
   G<small>NU</small> C translator was the easiest way to get it running.
   C programs produced by the translator depend on features of
   G<small>NU</small> C that may not be in other versions of C. They
   include arbitrary length names, hexadecimal floats, nested functions,
   statement expressions, and zero length arrays. Maybe this list is
   incomplete.
  </p>
  <p align="justify">
   <b>Q.</b> Is there an Orson compiler that produces machine code
   directly, instead of producing G<small>NU</small> C code and then
   compiling it?
  </p>
  <p align="justify">
   <b>A.</b> I don&rsquo;t have one. One way to make one would be to write
   an Orson front end for <small>GCC</small>. That would be better than
   trying to make Orson produce <small>ANSI</small> C. There are already
   similar front ends for other languages. I don&rsquo;t know enough about
   <small>GCC</small>&rsquo;s internals to do this myself.
  </p>
  <p align="justify">
   <b>Q.</b> I tried to compile an Orson program, but I got an error
   message that I don&rsquo;t understand. The compiler just stopped and said
   <tt>Orson:</tt>&nbsp;<tt>Got</tt>&nbsp;<tt>[Nil]</tt>&nbsp;<tt>in</tt>&nbsp;<tt>transform!</tt>
   What does it mean?
  </p>
  <p align="justify">
   <b>A.</b> It means you found a bug in the Orson compiler. Sorry. Any
   message that ends in an exclamation mark means Orson has detected a bug in
   itself. After it detects the bug, it halts without compiling your program.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I might try to fix the bug, if you send me
   the program that caused it. Be sure to tell me the version of the compiler
   you&rsquo;re using: you can find that out by typing
   <tt>orson</tt>&nbsp;<tt>-v</tt> to the shell. Also tell me if
   you&rsquo;re using a modified version of the prelude, etc.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Better yet, fix the bug yourself.
   You&rsquo;ve got the source code.
  </p>
  <p align="justify">
   <b>Q.</b> I looked at the standard prelude. It uses funny things like
   ?<i>nil</i> and ?<i>intAdd</i>(<i>l,</i>&nbsp;<i>r</i>).
   What are they? How can I use them in my programs?
  </p>
  <p align="justify">
   <b>A.</b> A name that starts with a question mark is a
   <i>hook.</i> (Question marks are shaped like hooks.) When Orson
   encounters a hook, it executes a corresponding C code fragment in the
   compiler. As a result, a hook can do anything that C can do, even things
   that are difficult or impossible in Orson.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You&rsquo;re not allowed to use hooks, unless
   they appear in an Orson source file with an <tt>.op</tt> suffix. Even
   then, it&rsquo;s a bad idea, unless you know what you&rsquo;re doing. Hooks
   are intended to be used only by the implementers and maintainers of the
   Orson compiler and library. (Right now that&rsquo;s only me.) You can crash
   the compiler by giving bad arguments to some hooks, so they should be used
   only inside methods that verify their arguments for them. Also, future
   versions of Orson may introduce new hooks, may eliminate old hooks, or may
   change how old hooks work.
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t your Orson compiler provide a 64-bit
   integer type, <i>int</i>3?
  </p>
  <p align="justify">
   <b>A.</b> Because it was developed on 32-bit computers, mostly with
   Intel <i>x</i>86 processors. There&rsquo;s no reason it couldn&rsquo;t
   provide <i>int</i>3, since the compiler translates Orson programs to
   G<small>NU</small> C, which is said to support 64-bit integers. The
   problem is that information about simple types appears in many different
   places throughout the present compiler. To provide <i>int</i>3,
   I&rsquo;d have to find all those places and make small changes to them. It
   wouldn&rsquo;t be hard, just tedious.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I shouldn&rsquo;t have designed the compiler
   that way. I should have kept information about simple types in one place, or
   in only a few places. If I ever rewrite the Orson compiler (maybe in Orson
   itself) I may do that.
  </p>
  <p align="justify">
   <b>Q.</b> (<i>Old question.</i>) I can&rsquo;t compile the Orson
   compiler on my Apple Macintosh computer. I can&rsquo;t compile
   G<small>NU</small> C code produced by the Orson compiler, either.
   What&rsquo;s wrong?
  </p>
  <p align="justify">
   <b>A.</b> In 2006, Apple stopped supporting nested functions in
   G<small>NU</small> C programs. Unfortunately, significant parts of the
   Orson compiler are written in continuation passing style
   (<small>CPS</small>), which is most easily simulated in
   G<small>NU</small> C with nested functions. G<small>NU</small> C
   code produced by the Orson compiler might also use nested functions, even if
   it doesn&rsquo;t use <small>CPS</small>.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Apple eliminated nested functions because the
   <small>GCC</small> compiler implements them using
   <i>trampolines:</i> code fragments that are written to the stack for
   later execution. However, putting executable code on the stack via a buffer
   overflow is also a favorite technique of crackers for gaining illegal access
   to a computer. Apple apparently tried to prevent such access by making it
   impossible to execute code on the stack.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As far as I know, the Orson compiler now
   works on current Apple systems, and so do the G<small>NU</small> C
   programs that it produces. It may be necessary to add extra options to the
   <small>GCC</small> command to make those things happen. I don&rsquo;t
   follow Apple any more, so I don&rsquo;t know what those things are. I also
   don&rsquo;t know if Apple now supports an executable stack, or if they fixed
   the problem in some other way.
  </p>
  <hr />
  <a name="misc">
  </a>
  <p>
   <b>14. Miscellaneous questions.</b>
  </p>
  <p align="justify">
   <b>Q.</b> Why doesn&rsquo;t Orson have a <i>return</i> statement?
  </p>
  <p align="justify">
   <b>A.</b> Orson is an expression language, so it doesn&rsquo;t have
   statements at all. I&rsquo;ll assume you mean an expression that, when
   executed, makes a procedure stop and return an object. In a statement
   language with <i>return</i>&rsquo;s, every path through a procedure
   body must end with one. At least it does if the procedure returns an object.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Java
   <a href="#gos1996">
    [<small>GOS</small> 1996]
   </a>
   compilers try to enumerate all such paths, complaining if they find one that
   doesn&rsquo;t end with a <i>return</i> statement. Unfortunately, Turing
   says it&rsquo;s impossible to do this. As a result, Java sometimes complains
   needlessly, and you must add dummy <i>return</i> statements to shut it
   up.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Some C
   <a href="#ker1988">
    [<small>KER</small> 1988]
   </a>
   compilers apparently don&rsquo;t care. They say that a procedure returns an
   unspecified object if it stops without executing a <i>return</i>
   statement. I&rsquo;m not sure if this is better than Java, or worse, but it
   has the virtue of being simpler.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Neither of these alternatives is correct, but
   since Orson is an expression language without <i>return</i>&rsquo;s,
   the problem goes away. An Orson procedure just returns the object to which
   its body evaluates. If the body has the wrong type, then this is detected by
   Orson&rsquo;s type system. Since the compiler has to check types anyway, it
   requires no extra work. This is yet another reason why expression languages
   are better than statement languages.
   <br>
   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are other problems with
   <i>return</i>&rsquo;s, too. For example, what happens if a
   <i>return</i> appears in a form body? Does it terminate the form during
   transformation? Does it transform to an expression that terminates a
   procedure during execution? Should there be two kinds of
   <i>return</i>&rsquo;s, one that terminates forms during transformation,
   and another that terminates procedures during execution? What happens if a
   <i>return</i> appears outside a method body? If there are no
   <i>return</i>&rsquo;s, then I don&rsquo;t have to answer these
   questions.
  </p>
  <hr />
  <a name="references">
  </a>
  <p align="center">
   <b>References</b>
  </p>
  <table cellpadding="0" cellspacing="0">
   <tr valign="top">
    <td>
     <p>
      <a name="and1991">
      </a>
      [<small>AND</small>&nbsp;1991]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      David P. Anderson, Ron Kuivila. &lsquo;&lsquo;Formula: A Programming
      Language for Expressive Computer Music.&rsquo;&rsquo;
      <i>I<small>EEE</small> Computer.</i> Volume 24, Number 7, July
      1991. Pages 12&#8211;21.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ans1986">
      </a>
      [<small>ANS</small>&nbsp;1986]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Anonymous. &lsquo;&lsquo;American National Standard Code for Information
      Interchange.&rsquo;&rsquo; American National Standards Institute.
      <small>ANSI</small> X3.4&#8211;1986.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="bar1984">
      </a>
      [<small>BAR</small>&nbsp;1984]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      H. P. Barendregt. <i>The Lambda Calculus: Its Syntax and
      Semantics.</i> Elsevier Science Publishers. Amsterdam, The
      Netherlands. 1984.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="des1967">
      </a>
      [<small>DES</small>&nbsp;1967]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Ralph De Sola. <i>Abbreviations Dictionary.</i> Meredith Press. New
      York, New York. 1967. Page 104.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="hen1979">
      </a>
      [<small>HEN</small>&nbsp;1979]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Bill Henkin. <i>The Rocky Horror Picture Show Book.</i> Hawthorn
      Books. New York, New York. 1979.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="hud1992">
      </a>
      [<small>HUD</small>&nbsp;1992]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Paul Hudak, Simon Peyton Jones, Philip Wadler, editors.
      &lsquo;&lsquo;Report on the Programming Language Haskell.&rsquo;&rsquo;
      <i>A<small>CM</small> S<small>IGPLAN</small> Notices.</i>
      Volume 27, Number 5, May 1992. Section R.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="jen1974">
      </a>
      [<small>JEN</small>&nbsp;1974]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Kathleen Jensen, Niklaus Wirth. <i>P<small>ASCAL</small> User
      Manual and Report.</i> Springer-Verlag. Berlin, Germany. 1974.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ker1988">
      </a>
      [<small>KER</small>&nbsp;1988]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Brian W. Kernighan, Dennis M. Ritchie. <i>The C Programming
      Language.</i> Second Edition. Prentice-Hall. Upper Saddle River, New
      Jersey. 1988.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="knu1975">
      </a>
      [<small>KNU</small>&nbsp;1975]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Donald E. Knuth. <i>The Art of Computer Programming. Fundamental
      Algorithms.</i> Second Edition. Addison-Wesley. Reading,
      Massachusetts. 1975. Pages 234&#8211;238.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="gos1996">
      </a>
      [<small>GOS</small>&nbsp;1996]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      James Gosling, Bill Joy, Guy Steele. <i>The Java Language
      Specification.</i> Addison-Wesley. Reading, Massachusetts. 1996.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="mcc1987">
      </a>
      [<small>MCC</small>&nbsp;1987]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Robert McCrum, William Cran, Robert MacNeil. <i>The Story of
      English.</i> Elizabeth Sifton Books. Viking Penguin, Inc. New York,
      New York. 1987. Page 19.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="moe2017">
      </a>
      [<small>MOE</small>&nbsp;2017]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      James B. Moen. &lsquo;&lsquo;The Revised&#8315;&#185; Report on the
      Algorithmic Language Orson.&rsquo;&rsquo; Unpublished technical report.
      2017.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="moo2001">
      </a>
      [<small>MOO</small>&nbsp;2001]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Glenn Moody. <i>Rebel Code.</i> Perseus Publishing. Cambridge,
      Massachusetts. 2001. Page 115.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="nau1963">
      </a>
      [<small>NAU</small>&nbsp;1963]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      J. W. Backus, F. L. Bauer, J. Green, C. Katz, J. McCarthy, P. Naur
      (editor), A. J. Perlis, H. Rutishauser, K. Samelson, B. Vauquois, J. H.
      Wegstein, A. van Wijngaarden, M. Woodger. &lsquo;&lsquo;Revised Report on
      the Algorithmic Language Algol 60.&rsquo;&rsquo; <i>Communications of
      the ACM.</i> Volume 6. Number 1. January 1963. Pages 1&#8211;17.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="okr1992">
      </a>
      [<small>OKR</small>&nbsp;1992]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Marc Okrand. <i>The Klingon Dictionary.</i> Pocket Books. New York,
      New York. 1992.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="pow2001">
      </a>
      [<small>POW</small>&nbsp;2001]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Thomas A. Powell. <i>H<small>TML</small>: The Complete
      Reference.</i> Third Edition. Osborne/McGraw Hill. Berkeley,
      California. 2001.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ruc1982">
      </a>
      [<small>RUC</small>&nbsp;1982]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Rudy Rucker. <i>Infinity and the Mind.</i> Birkhauser. Boston,
      Massachusetts. 1982. Page 193.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="sam1969">
      </a>
      [<small>SAM</small>&nbsp;1969]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Jean E. Sammet. <i>Programming Languages: History and
      Fundamentals.</i> Prentice-Hall. Englewood Cliffs, New Jersey. 1969.
      Pages 388&#8211;400.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="sch1967">
      </a>
      [<small>SCH</small>&nbsp;1967]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Herbert Schorr, William M. Waite. &lsquo;&lsquo;An Efficient
      Machine-Independent Procedure for Garbage Collection in Various List
      Structures.&rsquo;&rsquo; <i>Communications of the
      A<small>CM</small>.</i> Volume 10, Number 8, August 1967. Pages
      501&#8211;506.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="sta2008">
      </a>
      [<small>STA</small>&nbsp;2008]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Richard M. Stallman, the G<small>CC</small> Developer Community.
      &lsquo;&lsquo;Using and Porting the G<small>NU</small> Compiler
      Collection.&rsquo;&rsquo; Free Software Foundation. Boston,
      Massachusetts. 2008.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="ste1990">
      </a>
      [<small>STE</small>&nbsp;1990]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Guy L. Steele Jr. <i>Common Lisp: The Language.</i> Second Edition.
      Digital Press. Bedford, Massachusetts. 1990.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="str1994">
      </a>
      [<small>STR</small>&nbsp;1994]&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Bjarne Stroustrup. <i>The C++ Programming Language.</i> Second
      Edition. Addison-Wesley. Reading, Massachusetts. 1994.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="stv2005">
      </a>
      [<small>STV</small>&nbsp;2005]
     </p>
    </td>
    <td>
     <p align="justify">
      W. Richard Stevens, Stephen A. Rago. <i>Advanced Programming in the
      U<small>NIX</small> Environment.</i> Second Edition.
      Addison-Wesley. Upper Saddle River, New Jersey. 2005. Chapters
      11&#8211;12.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="upd1986">
      </a>
      [<small>UPD</small>&nbsp;1986]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      John Updike. <i>Roger&rsquo;s Version.</i> Ballantine Books. New
      York, New York. 1986.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="uni2006">
      </a>
      [<small>UNI</small>&nbsp;2006]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      The Unicode Consortium. <i>The Unicode Standard, Version 5.0.</i>
      Fifth Edition. Addison-Wesley Professional. Reading, Massachusetts. 2006.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="vwi1977">
      </a>
      [<small>VWI</small>&nbsp;1977]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      A. van Wijngaarden, B. J. Mailloux, J. E. L. Peck, C. H. A. Koster, M.
      Sintzoff, C. H. Lindsey, L. G. L. T. Meertens, R. G. Fisker.
      &lsquo;&lsquo;Revised Report on the Algorithmic Language Algol
      68.&rsquo;&rsquo; A<small>CM</small> S<small>IGPLAN</small>
      Notices. Volume 12. Number 5. May 1977. Pages 1&#8211;70.
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      &nbsp;
     </p>
    </td>
    <td>
     <p>
      &nbsp;
     </p>
    </td>
   </tr>
   <tr valign="top">
    <td>
     <p>
      <a name="wei1988">
      </a>
      [<small>WEI</small>&nbsp;1988]&nbsp;&nbsp;
     </p>
    </td>
    <td>
     <p align="justify">
      Charles B. Weinstock, William A. Wulf. &lsquo;&lsquo;An Efficient
      Algorithm for Heap Storage Allocation.&rsquo;&rsquo;
      <i>A<small>CM</small> S<small>IGPLAN</small> Notices.</i>
      Volume 23, Number 10, October 1988. Pages 141&#8211;146.
     </p>
    </td>
   </tr>
  </table>

		<script class="matomo-analytics" type='text/javascript'>
		 var _paq = _paq || [];
		 _paq.push(['setDocumentTitle', document.domain + ' -/- ' + document.title]);
		 _paq.push(['setDomains', '*.jmthornton.net']);
		 _paq.push(['setCookieDomains', '*.jmthornton.net']);
		 _paq.push(['trackPageView']);
		 _paq.push(['enableLinkTracking']);
		 void function() {
			 var u='https://jmthornton.net/analytics/';
			 _paq.push(['setTrackerUrl', u+'piwik.php']);
			 _paq.push(['setSiteId', '1']);
			 const d=document,
						 g=d.createElement('script'),
						 s=d.getElementsByTagName('script')[0];
			 g.type='text/javascript';
			 g.async=true;
			 g.defer=true;
			 g.src=u+'piwik.js';
			 s.parentNode.insertBefore(g,s);
		 }();
		</script>
 </body>
</html>
